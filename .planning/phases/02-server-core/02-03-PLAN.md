---
phase: 02-server-core
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - MASK-02
  - MASK-03
  - MASK-04
  - MASK-05
  - MASK-06

must_haves:
  truths:
    - "nginx config has WebSocket location block with proxy_pass trailing slash and proxy_buffering off"
    - "Three masquerade modes produce different nginx location / blocks: stub returns HTML, proxy reverse-proxies URL, static serves local files"
    - "Existing nginx config for the domain is detected and WebSocket block is injected without replacing the rest"
    - "TLS cert is checked before calling certbot --- existing cert is reused, no duplicate issuance"
    - "certbot uses certonly --nginx (does not modify nginx config)"
    - "MASK-06 (HTTPS-only without nginx) is handled by nginx always being used, with a note in code"
  artifacts:
    - path: "proxyebator.sh"
      provides: "server_configure_nginx, server_obtain_tls functions"
      contains: "proxy_buffering off"
    - path: "/etc/nginx/sites-available/proxyebator-DOMAIN.conf"
      provides: "nginx server block with WebSocket proxy and cover site"
      contains: "proxy_pass http://127.0.0.1:7777/"
  key_links:
    - from: "server_configure_nginx()"
      to: "nginx config file"
      via: "cat > writes full server block or injects location block"
      pattern: "proxy_pass http://127.0.0.1:7777/"
    - from: "nginx location /SECRET_PATH/"
      to: "Chisel on 127.0.0.1:7777"
      via: "proxy_pass with trailing slash"
      pattern: "proxy_pass http://127.0.0.1:7777/;"
    - from: "server_obtain_tls()"
      to: "certbot certonly"
      via: "conditional call if cert not found"
      pattern: "certbot certonly.*--nginx"
---

<objective>
Configure nginx as a reverse proxy with WebSocket tunneling and a cover site, then obtain a TLS certificate via certbot.

Purpose: nginx is the masking layer --- it makes the tunnel look like a normal website. The WebSocket location block must have trailing slash in proxy_pass and proxy_buffering off (both are non-negotiable or the tunnel silently breaks). TLS via certbot makes the traffic indistinguishable from normal HTTPS browsing.

Output: server_configure_nginx() and server_obtain_tls() functions wired into server_main(). nginx config file written to /etc/nginx/sites-available/.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-core/02-RESEARCH.md
@.planning/phases/02-server-core/02-CONTEXT.md
@.planning/phases/02-server-core/02-02-SUMMARY.md
@proxyebator.sh
@tunnel-reference.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement nginx configuration with three masquerade modes</name>
  <files>proxyebator.sh</files>
  <action>
Add the server_configure_nginx() function and its helpers to proxyebator.sh, after server_create_systemd() and before server_main().

**detect_existing_nginx():**
- Search for existing nginx config referencing the domain: `grep -rl "server_name.*${DOMAIN}" /etc/nginx/ 2>/dev/null | head -1`
- If found: set `NGINX_EXISTING_CONF="$existing"`, log_warn
- If not: set `NGINX_EXISTING_CONF=""`

**generate_masquerade_block():**
Returns the nginx location / block based on MASQUERADE_MODE:
- **stub mode:** Return an inline HTML response:
  ```nginx
  location / {
      return 200 '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Welcome</title><style>body{font-family:sans-serif;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:#f5f5f5}div{text-align:center;color:#333}</style></head><body><div><h1>Welcome</h1><p>This site is under construction.</p></div></body></html>';
      add_header Content-Type text/html;
  }
  ```
- **proxy mode:** Reverse-proxy the user-provided URL:
  ```nginx
  location / {
      proxy_pass PROXY_URL;
      proxy_set_header Host PROXY_HOST;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_ssl_server_name on;
  }
  ```
  Extract PROXY_HOST from PROXY_URL: `printf '%s' "$PROXY_URL" | sed 's|https\?://||;s|/.*||'`
- **static mode:** Serve local files:
  ```nginx
  root STATIC_PATH;
  location / {
      try_files $uri $uri/ =404;
  }
  ```

**generate_tunnel_location_block():**
Returns the WebSocket location block. This is HARDCODED, never configurable:
```nginx
# proxyebator-tunnel-block-start
location /${SECRET_PATH}/ {
    proxy_pass http://127.0.0.1:7777/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;
    proxy_buffering off;
}
# proxyebator-tunnel-block-end
```
CRITICAL: `proxy_pass http://127.0.0.1:7777/;` --- trailing slash is MANDATORY. `proxy_buffering off;` --- MANDATORY. These are NOT configurable.

**server_configure_nginx():**
1. Call detect_existing_nginx()
2. If NGINX_EXISTING_CONF is not empty (existing config found):
   - Check if tunnel block already injected: `grep -q "proxyebator-tunnel-block-start" "$NGINX_EXISTING_CONF"` --- if yes, log_info "already present", skip injection
   - If not present: create a backup `cp "$NGINX_EXISTING_CONF" "${NGINX_EXISTING_CONF}.bak.$(date +%s)"`
   - Generate the tunnel location block
   - Use sed to insert BEFORE the first `location /` in the file. Use a temp file approach:
     ```bash
     local tunnel_block tmpconf
     tunnel_block=$(generate_tunnel_location_block)
     tmpconf=$(mktemp)
     # Insert tunnel block before first 'location /' line
     awk -v block="$tunnel_block" '/location \/ \{/ && !inserted {print block; inserted=1} {print}' \
         "$NGINX_EXISTING_CONF" > "$tmpconf"
     mv "$tmpconf" "$NGINX_EXISTING_CONF"
     ```
   - Set NGINX_CONF_PATH="$NGINX_EXISTING_CONF"
3. If no existing config (new setup):
   - Set config path: `NGINX_CONF_PATH="${NGINX_CONF_DIR}/proxyebator-${DOMAIN}.conf"`
   - Generate full server block with:
     - Port 80 redirect to HTTPS
     - LISTEN_PORT ssl http2 server block
     - ssl_certificate and ssl_certificate_key pointing to Let's Encrypt paths (written as placeholders, certbot will provide actual certs)
     - WebSocket tunnel location block (from generate_tunnel_location_block)
     - Masquerade block (from generate_masquerade_block)
   - Write to $NGINX_CONF_PATH using cat heredoc
   - If NGINX_CONF_LINK is set (Debian/Ubuntu sites-enabled): create symlink `ln -sf "$NGINX_CONF_PATH" "${NGINX_CONF_LINK}/$(basename "$NGINX_CONF_PATH")"`
   - NOTE: Write nginx config WITHOUT ssl_certificate lines initially (certbot will add them, OR we add after obtaining cert). Use a two-pass approach:
     - First write: HTTP-only config (listen 80 + server_name) so nginx can start for ACME challenge
     - After server_obtain_tls: update config to add SSL block
     - OR: Write full config with ssl lines pointing to expected cert paths, and run certbot certonly (which does NOT modify the config). Since we call `certbot certonly --nginx`, nginx must already have the server_name configured. This approach works because certbot certonly --nginx only reads the nginx config to find the domain, it doesn't modify it. The certs will be at the standard paths.
     - CHOSEN: Write the full config with SSL lines pointing to `/etc/letsencrypt/live/${DOMAIN}/fullchain.pem` and `privkey.pem`. nginx will fail to start until certs exist, BUT we will NOT reload nginx until after certbot runs. Use: `nginx -t 2>/dev/null` AFTER certbot, not before.
4. Test nginx config only if certs already exist: `[[ -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]] && nginx -t && systemctl reload nginx`
5. If certs don't exist yet (new install), write a temporary HTTP-only config first for certbot, then overwrite with the full SSL config after server_obtain_tls. The approach:
   - Write a minimal HTTP config with just server_name and root (no SSL) to NGINX_CONF_PATH
   - Reload nginx so it serves port 80 for ACME
   - After certbot succeeds (in server_obtain_tls), overwrite NGINX_CONF_PATH with the full SSL + WebSocket + masquerade config
   - Reload nginx again

IMPLEMENTATION NOTE: To keep this clean, write TWO nginx configs: first a temporary HTTP-only version for certbot, then the final HTTPS version. server_configure_nginx writes the HTTP version and reloads. server_obtain_tls runs certbot. Then server_configure_nginx_final() writes the full version and reloads. But to avoid over-engineering, use a simpler approach: check if cert exists FIRST. If cert already exists, write the full config. If not, write HTTP-only, let certbot run, then write full config. Encapsulate the final config write in a separate function `write_nginx_full_config()` called both from server_configure_nginx (if cert exists) and from after certbot.

Let me simplify. The cleanest approach (from research):
1. server_configure_nginx: Always write HTTP-only config first. Reload nginx. Store full config template in a variable or a function.
2. server_obtain_tls: Runs certbot. Then calls write_nginx_ssl_config() which writes the full SSL config and reloads.
  </action>
  <verify>
Run `bash -n proxyebator.sh` --- must exit 0.
Verify trailing slash: `grep "proxy_pass http://127.0.0.1:7777/" proxyebator.sh` --- must be present with trailing slash.
Verify proxy_buffering off: `grep "proxy_buffering off" proxyebator.sh` --- must be present.
Verify three masquerade modes: `grep -c 'stub\|proxy\|static' proxyebator.sh` --- must find mode handling for all three.
Verify no missing mandatory directive: all of proxy_http_version 1.1, Upgrade, Connection "upgrade", proxy_read_timeout 3600s, proxy_send_timeout 3600s must be present.
  </verify>
  <done>
server_configure_nginx writes nginx config with WebSocket location block (trailing slash + proxy_buffering off hardcoded), three masquerade modes (stub HTML, proxy reverse-proxy, static root), existing config detection and injection with backup. HTTP-only config written first for certbot ACME.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TLS certificate acquisition and final nginx config</name>
  <files>proxyebator.sh</files>
  <action>
Add the server_obtain_tls() function and the write_nginx_ssl_config() helper. Insert after server_configure_nginx() and before server_main().

**check_existing_cert():**
- Check Let's Encrypt standard path: `/etc/letsencrypt/live/${DOMAIN}/fullchain.pem`
  - If exists: set CERT_PATH and CERT_KEY_PATH, return 0
- Check existing nginx config for ssl_certificate directive (for non-LE certs):
  ```bash
  if [[ -n "${NGINX_EXISTING_CONF:-}" ]]; then
      local existing_cert
      existing_cert=$(grep -o 'ssl_certificate [^;]*' "$NGINX_EXISTING_CONF" 2>/dev/null | awk '{print $2}' | head -1)
      if [[ -n "$existing_cert" && -f "$existing_cert" ]]; then
          CERT_PATH="$existing_cert"
          CERT_KEY_PATH=$(grep -o 'ssl_certificate_key [^;]*' "$NGINX_EXISTING_CONF" 2>/dev/null | awk '{print $2}' | head -1)
          return 0
      fi
  fi
  ```
- Return 1 if no cert found

**server_obtain_tls():**
1. Call check_existing_cert --- if returns 0, log_info "TLS cert already exists --- reusing" and skip certbot
2. If no cert found:
   - Ensure nginx is running (for --nginx plugin): `systemctl start nginx 2>/dev/null || true`
   - Run certbot:
     ```bash
     certbot certonly \
         --nginx \
         --non-interactive \
         --agree-tos \
         --register-unsafely-without-email \
         -d "$DOMAIN" \
         || die "certbot failed to obtain TLS certificate for $DOMAIN. Check DNS and port 80 access."
     ```
   - NOTE: Use `--register-unsafely-without-email` to avoid email prompt (per research open question --- automation-friendly)
   - NOTE: Use `certbot certonly --nginx` NOT `certbot --nginx` (certonly does NOT modify nginx config)
   - Set CERT_PATH and CERT_KEY_PATH to standard Let's Encrypt paths
3. After cert is available (either existing or newly obtained):
   - Call write_nginx_ssl_config() to write the full SSL configuration
   - Enable certbot renewal timer:
     ```bash
     if systemctl list-units --type=timer 2>/dev/null | grep -q "snap.certbot"; then
         systemctl enable --now snap.certbot.renew.timer 2>/dev/null || true
     else
         systemctl enable --now certbot.timer 2>/dev/null || true
     fi
     ```

**write_nginx_ssl_config():**
Writes the complete nginx config with SSL to NGINX_CONF_PATH. Only called for NEW configs (not existing ones where we only injected). If NGINX_EXISTING_CONF was set, skip this (existing config already has SSL).

For new configs, write the full server block:
```nginx
server {
    listen 80;
    server_name DOMAIN;
    return 301 https://$host$request_uri;
}

server {
    listen LISTEN_PORT ssl http2;
    server_name DOMAIN;

    ssl_certificate     CERT_PATH;
    ssl_certificate_key CERT_KEY_PATH;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;

    # WebSocket tunnel block
    [generate_tunnel_location_block output]

    # Cover site
    [generate_masquerade_block output]
}
```

After writing:
```bash
nginx -t || die "nginx configuration test failed"
systemctl reload nginx || die "Failed to reload nginx"
log_info "nginx configured with TLS and masquerade mode: $MASQUERADE_MODE"
```

**Update server_main():**
Add server_configure_nginx and server_obtain_tls after server_create_systemd:
```bash
server_main() {
    check_root
    detect_os
    detect_arch
    server_collect_params
    server_show_summary
    server_install_deps
    server_download_chisel
    server_setup_auth
    server_create_systemd
    server_configure_nginx
    server_obtain_tls
    # Phase 2 Plan 04 will add: server_configure_firewall, server_save_config, server_verify
    log_warn "Phase 2 Plan 03 complete: nginx + TLS configured. Remaining: firewall, config, verify."
}
```

**MASK-06 handling:** Add a comment in the code near masquerade mode handling: `# MASK-06 (HTTPS-only without nginx) removed by design --- nginx is always used. All three modes (stub/proxy/static) go through nginx.`
  </action>
  <verify>
Run `bash -n proxyebator.sh` --- must exit 0.
Verify certbot command: `grep 'certbot certonly' proxyebator.sh` --- must use certonly, not bare certbot.
Verify cert existence check: `grep 'fullchain.pem' proxyebator.sh` --- must check before calling certbot.
Verify MASK-06 note: `grep 'MASK-06' proxyebator.sh` --- must have explanatory comment.
Verify server_main includes server_configure_nginx and server_obtain_tls calls.
  </verify>
  <done>
server_obtain_tls checks existing certs (LE path + nginx config), runs certbot certonly --nginx only if needed, with --register-unsafely-without-email for automation. write_nginx_ssl_config writes the full SSL + WebSocket + masquerade config for new setups. server_main updated through TLS step. MASK-06 documented as removed by design.
  </done>
</task>

</tasks>

<verification>
1. `bash -n proxyebator.sh` exits 0
2. nginx config has ALL mandatory WebSocket directives: proxy_pass with trailing slash, proxy_buffering off, proxy_http_version 1.1, Upgrade header, Connection "upgrade", proxy_read_timeout 3600s, proxy_send_timeout 3600s
3. Three masquerade modes produce different nginx blocks
4. Existing nginx config detection and safe injection with backup
5. certbot uses certonly (not bare --nginx) and checks cert existence first
6. MASK-06 is documented as removed
7. server_main calls functions in correct order through server_obtain_tls
</verification>

<success_criteria>
- nginx WebSocket proxy has trailing slash and proxy_buffering off (non-negotiable)
- Three masquerade modes (stub/proxy/static) produce correct nginx blocks
- Existing nginx configs are detected and handled (inject, don't replace)
- certbot only called if cert doesn't already exist (rate limit protection)
- Full SSL config written and nginx reloaded after cert is available
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-core/02-03-SUMMARY.md`
</output>
