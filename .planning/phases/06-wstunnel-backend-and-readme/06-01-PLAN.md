---
phase: 06-wstunnel-backend-and-readme
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - TUNNEL-04
must_haves:
  truths:
    - "Running ./proxyebator.sh server --tunnel wstunnel downloads wstunnel binary and starts systemd service"
    - "wstunnel server listens on 127.0.0.1:7778 (not 0.0.0.0)"
    - "nginx location block uses port 7778 for wstunnel, 7777 for chisel"
    - "server.conf records TUNNEL_TYPE=wstunnel and TUNNEL_PORT=7778"
    - "Uninstall removes wstunnel binary when TUNNEL_TYPE=wstunnel"
    - "Client mode launches wstunnel client with -L socks5:// when server used wstunnel"
    - "Connection info prints wstunnel client command (not chisel) when TUNNEL_TYPE=wstunnel"
    - "Verification suite passes for wstunnel (TUNNEL_PORT=7778 used in all checks)"
  artifacts:
    - path: "proxyebator.sh"
      provides: "wstunnel backend alongside chisel"
      contains: "server_download_wstunnel"
  key_links:
    - from: "server_collect_params"
      to: "TUNNEL_TYPE variable"
      via: "interactive prompt or --tunnel flag"
      pattern: "chisel|wstunnel"
    - from: "server_main"
      to: "server_download_wstunnel / server_create_systemd_wstunnel"
      via: "if TUNNEL_TYPE == wstunnel branch"
      pattern: "TUNNEL_TYPE.*wstunnel"
    - from: "generate_tunnel_location_block"
      to: "TUNNEL_PORT"
      via: "variable interpolation in proxy_pass"
      pattern: "proxy_pass.*TUNNEL_PORT"
    - from: "server_save_config"
      to: "TUNNEL_PORT"
      via: "conditional port assignment"
      pattern: "tunnel_port=7778"
---

<objective>
Add wstunnel as a second tunnel backend alongside chisel in proxyebator.sh.

Purpose: Users can select wstunnel at install time via interactive prompt or --tunnel wstunnel flag. The entire server pipeline (download, systemd, nginx, firewall, config, verify, connection info) and client pipeline work for both backends.

Output: Modified proxyebator.sh with wstunnel support in all relevant functions.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-wstunnel-backend-and-readme/06-RESEARCH.md
@proxyebator.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: wstunnel server functions and server_main branching</name>
  <files>proxyebator.sh</files>
  <action>
Modify proxyebator.sh to add wstunnel server support. All changes are in the single file. Reference the research at 06-RESEARCH.md for exact commands and flags.

**1. server_collect_params (line ~519-523): Replace the chisel-only TUNNEL_TYPE block.**

Replace:
```bash
if [[ -z "$TUNNEL_TYPE" ]]; then
    TUNNEL_TYPE="chisel"
elif [[ "$TUNNEL_TYPE" != "chisel" ]]; then
    die "Tunnel type '${TUNNEL_TYPE}' is not yet supported. Only 'chisel' is available (wstunnel coming in Phase 6)."
fi
```

With:
```bash
if [[ -z "$TUNNEL_TYPE" ]]; then
    printf "${CYAN}[?]${NC} Tunnel backend [chisel/wstunnel] (default: chisel): "
    read -r TUNNEL_TYPE
    TUNNEL_TYPE="${TUNNEL_TYPE:-chisel}"
fi
case "${TUNNEL_TYPE}" in
    chisel|wstunnel) ;;
    *) die "Unknown tunnel type '${TUNNEL_TYPE}'. Use 'chisel' or 'wstunnel'." ;;
esac
```

BUT: if CLI_MODE is true (DOMAIN was pre-set), the prompt should be skipped — TUNNEL_TYPE defaults to "chisel" if empty. So wrap the prompt in `[[ "${CLI_MODE}" == "false" ]]` or check `[[ ! -t 0 ]]`. Actually, the simplest approach matching existing patterns: check if TUNNEL_TYPE is already set (from --tunnel flag). If not set AND interactive, prompt. If not set AND non-interactive, default to chisel:
```bash
if [[ -z "$TUNNEL_TYPE" ]]; then
    if [[ "${CLI_MODE}" == "false" ]]; then
        printf "${CYAN}[?]${NC} Tunnel backend [chisel/wstunnel] (default: chisel): "
        read -r TUNNEL_TYPE
    fi
    TUNNEL_TYPE="${TUNNEL_TYPE:-chisel}"
fi
case "${TUNNEL_TYPE}" in
    chisel|wstunnel) ;;
    *) die "Unknown tunnel type '${TUNNEL_TYPE}'. Use 'chisel' or 'wstunnel'." ;;
esac
```

Note: CLI_MODE is set just above this code, so it is available. The prompt placement should be after detect_listen_port and before secret generation, matching the existing flow.

**2. Add server_download_wstunnel function (after server_download_chisel, around line ~644).**

```bash
server_download_wstunnel() {
    if [[ -x /usr/local/bin/wstunnel ]]; then
        log_info "wstunnel already installed: $(/usr/local/bin/wstunnel --version 2>&1 | head -1)"
        return
    fi

    rm -f /tmp/wstunnel.tar.gz /tmp/wstunnel 2>/dev/null || true

    local WSTUNNEL_FALLBACK_VER="v10.5.2"
    local WSTUNNEL_VER
    WSTUNNEL_VER=$(curl -sf --max-time 10 \
        "https://api.github.com/repos/erebe/wstunnel/releases/latest" \
        | grep -o '"tag_name": "[^"]*"' | grep -o 'v[0-9.]*') \
        || WSTUNNEL_VER=""

    if [[ -z "$WSTUNNEL_VER" ]]; then
        log_warn "Could not fetch latest wstunnel version — using fallback ${WSTUNNEL_FALLBACK_VER}"
        WSTUNNEL_VER="$WSTUNNEL_FALLBACK_VER"
    fi

    # wstunnel uses .tar.gz (NOT .gz like chisel) — must use tar, not gunzip
    local download_url="https://github.com/erebe/wstunnel/releases/download/${WSTUNNEL_VER}/wstunnel_${WSTUNNEL_VER#v}_linux_${ARCH}.tar.gz"
    log_info "Downloading wstunnel ${WSTUNNEL_VER} for ${ARCH} from GitHub..."

    curl -fLo /tmp/wstunnel.tar.gz "$download_url" \
        || die "Failed to download wstunnel from $download_url"
    tar -xzf /tmp/wstunnel.tar.gz -C /tmp/ wstunnel \
        || die "Failed to extract wstunnel binary from tarball"
    rm -f /tmp/wstunnel.tar.gz
    chmod +x /tmp/wstunnel
    mv /tmp/wstunnel /usr/local/bin/wstunnel

    /usr/local/bin/wstunnel --version \
        || die "wstunnel binary not working after install"
    log_info "wstunnel installed: $(/usr/local/bin/wstunnel --version 2>&1 | head -1)"
}
```

**3. Add server_create_systemd_wstunnel function (after server_create_systemd, around line ~710).**

```bash
server_create_systemd_wstunnel() {
    if systemctl is-active --quiet proxyebator 2>/dev/null; then
        log_info "proxyebator.service is already active — skipping service creation"
        return
    fi

    # wstunnel server: no auth flags needed — nginx location block IS the auth gate
    # wstunnel binds to 127.0.0.1 only — unreachable from outside
    # DO NOT use --restrict-http-upgrade-path-prefix: nginx trailing-slash proxy_pass
    # strips the path before forwarding, causing wstunnel to reject all connections
    cat > /etc/systemd/system/proxyebator.service << 'UNIT'
[Unit]
Description=wstunnel Server (proxyebator)
After=network.target

[Service]
ExecStart=/usr/local/bin/wstunnel server ws://127.0.0.1:7778
Restart=always
RestartSec=5
User=nobody
Group=nogroup

[Install]
WantedBy=multi-user.target
UNIT

    systemctl daemon-reload
    systemctl enable --now proxyebator || die "Failed to start proxyebator.service"
    log_info "wstunnel systemd service: $(systemctl is-active proxyebator 2>/dev/null || echo 'unknown')"
}
```

**4. Update generate_tunnel_location_block (line ~760-781): Use TUNNEL_PORT variable instead of hardcoded 7777.**

Replace the hardcoded `http://127.0.0.1:7777/` in the heredoc with `http://127.0.0.1:${TUNNEL_PORT:-7777}/`. Since the function uses a heredoc with variable expansion (TUNNEL_BLOCK delimiter is not quoted), this works directly. The current code has:
```
proxy_pass http://127.0.0.1:7777/;
```
Change to:
```
proxy_pass http://127.0.0.1:${TUNNEL_PORT:-7777}/;
```

Also set TUNNEL_PORT before this function is called. Add at the top of server_main, after server_collect_params:
```bash
# Set TUNNEL_PORT based on backend type
if [[ "${TUNNEL_TYPE}" == "wstunnel" ]]; then
    TUNNEL_PORT=7778
else
    TUNNEL_PORT=7777
fi
```

**5. Update server_main (line ~1256-1273): Branch on TUNNEL_TYPE for download and systemd.**

Replace:
```bash
server_main() {
    check_root
    detect_os
    detect_arch
    server_collect_params
    server_show_summary
    server_install_deps
    server_download_chisel
    server_setup_auth
    server_create_systemd
    server_configure_nginx
    server_obtain_tls
    server_configure_firewall
    server_save_config
    verify_main
    local verify_exit=$?
    exit $verify_exit
}
```

With:
```bash
server_main() {
    check_root
    detect_os
    detect_arch
    server_collect_params

    # Set TUNNEL_PORT based on backend type
    if [[ "${TUNNEL_TYPE}" == "wstunnel" ]]; then
        TUNNEL_PORT=7778
    else
        TUNNEL_PORT=7777
    fi

    server_show_summary
    server_install_deps

    if [[ "${TUNNEL_TYPE}" == "wstunnel" ]]; then
        server_download_wstunnel
        server_create_systemd_wstunnel
    else
        server_download_chisel
        server_setup_auth
        server_create_systemd
    fi

    server_configure_nginx
    server_obtain_tls
    server_configure_firewall
    server_save_config
    verify_main
    local verify_exit=$?
    exit $verify_exit
}
```

Note: TUNNEL_PORT must be set BEFORE server_show_summary because server_show_summary displays tunnel info. Also must be set before generate_tunnel_location_block is called (via server_configure_nginx).

**6. Update server_show_summary (line ~548-553): Show correct tunnel info based on TUNNEL_TYPE.**

Replace the hardcoded tunnel summary line:
```bash
printf "  Tunnel:       Chisel (port 7777, bound to 127.0.0.1)\n"
```
With:
```bash
if [[ "${TUNNEL_TYPE}" == "wstunnel" ]]; then
    printf "  Tunnel:       wstunnel (port 7778, bound to 127.0.0.1)\n"
else
    printf "  Tunnel:       Chisel (port 7777, bound to 127.0.0.1)\n"
fi
```

**7. Update server_save_config (line ~995-1022): Dynamic TUNNEL_PORT and TUNNEL_TYPE.**

Replace the hardcoded lines in the heredoc:
```
TUNNEL_TYPE=chisel
TUNNEL_PORT=7777
```
With:
```
TUNNEL_TYPE=${TUNNEL_TYPE}
TUNNEL_PORT=${TUNNEL_PORT}
```

Also: for wstunnel, AUTH_USER and AUTH_TOKEN are still generated (they are used by chisel path) but won't be used. However, they must still exist in the config for uninstall and re-run compatibility. Keep them in the config file.

**8. Update server_configure_firewall (line ~959-991): Use TUNNEL_PORT instead of hardcoded 7777.**

Replace every occurrence of `7777` with `${TUNNEL_PORT}`. There are 6 occurrences of `7777` in this function — in ufw deny, iptables -C, iptables -A, and log_info messages. Change all to `${TUNNEL_PORT}`.

**9. Update _uninstall_binary (line ~1354-1366): Branch on TUNNEL_TYPE.**

Replace:
```bash
_uninstall_binary() {
    if [[ -f /usr/local/bin/chisel ]]; then
        rm -f /usr/local/bin/chisel
        log_info "Removed /usr/local/bin/chisel"
    else
        log_info "Chisel binary: not found, skipping"
    fi
    if [[ -f /etc/chisel/auth.json ]]; then
        rm -f /etc/chisel/auth.json
        log_info "Removed /etc/chisel/auth.json"
    fi
    rmdir /etc/chisel 2>/dev/null || true
}
```

With:
```bash
_uninstall_binary() {
    if [[ "${TUNNEL_TYPE:-chisel}" == "wstunnel" ]]; then
        if [[ -f /usr/local/bin/wstunnel ]]; then
            rm -f /usr/local/bin/wstunnel
            log_info "Removed /usr/local/bin/wstunnel"
        else
            log_info "wstunnel binary: not found, skipping"
        fi
    else
        if [[ -f /usr/local/bin/chisel ]]; then
            rm -f /usr/local/bin/chisel
            log_info "Removed /usr/local/bin/chisel"
        else
            log_info "Chisel binary: not found, skipping"
        fi
        if [[ -f /etc/chisel/auth.json ]]; then
            rm -f /etc/chisel/auth.json
            log_info "Removed /etc/chisel/auth.json"
        fi
        rmdir /etc/chisel 2>/dev/null || true
    fi
}
```

**10. Update _uninstall_confirm (line ~1314-1334): Show correct binary in removal list.**

Update the display to show wstunnel binary instead of chisel when TUNNEL_TYPE is wstunnel. The lines showing "Chisel binary" and "Auth file" should be conditional. Also update the firewall display to use TUNNEL_PORT (it currently hardcodes 7777).

**11. Update _uninstall_firewall (line ~1405-1417): Use TUNNEL_PORT instead of hardcoded 7777.**

Replace `7777` with `${TUNNEL_PORT:-7777}` in both the ufw and iptables branches.

**12. Update server_print_connection_info (line ~1026-1046): Branch on TUNNEL_TYPE for client command.**

After the existing chisel client command block, add a conditional for wstunnel:
```bash
server_print_connection_info() {
    printf "\n${BOLD}=== Connection Information ===${NC}\n"
    printf "${GREEN}Server setup complete!${NC}\n\n"

    if [[ "${TUNNEL_TYPE:-chisel}" == "wstunnel" ]]; then
        printf "  ${BOLD}Client command (wstunnel):${NC}\n"
        printf "  ${CYAN}wstunnel client \\\\${NC}\n"
        printf "  ${CYAN}  -L socks5://127.0.0.1:1080 \\\\${NC}\n"
        printf "  ${CYAN}  --connection-min-idle 5 \\\\${NC}\n"
        printf "  ${CYAN}  wss://%s:%s/%s/${NC}\n" "${DOMAIN}" "${LISTEN_PORT}" "${SECRET_PATH}"
        printf "\n"
        printf "  ${BOLD}Команда для клиентской машины:${NC}\n"
        printf "  ${CYAN}./proxyebator.sh client --host %s --port %s --path /%s/ --tunnel wstunnel${NC}\n" \
            "${DOMAIN}" "${LISTEN_PORT}" "${SECRET_PATH}"
    else
        printf "  ${BOLD}Client command:${NC}\n"
        printf "  ${CYAN}chisel client \\\\${NC}\n"
        printf "  ${CYAN}  --auth \"%s:%s\" \\\\${NC}\n" "${AUTH_USER}" "${AUTH_TOKEN}"
        printf "  ${CYAN}  --keepalive 25s \\\\${NC}\n"
        printf "  ${CYAN}  https://%s:%s/%s/ \\\\${NC}\n" "${DOMAIN}" "${LISTEN_PORT}" "${SECRET_PATH}"
        printf "  ${CYAN}  socks${NC}\n"
        printf "\n"
        printf "  ${BOLD}Команда для клиентской машины:${NC}\n"
        printf "  ${CYAN}./proxyebator.sh client wss://%s:%s@%s:%s/%s/${NC}\n" \
            "${AUTH_USER}" "${AUTH_TOKEN}" "${DOMAIN}" "${LISTEN_PORT}" "${SECRET_PATH}"
    fi

    printf "\n"
    printf "  ${BOLD}SOCKS5 proxy will be available at:${NC} 127.0.0.1:1080\n"
    printf "\n"
    printf "  ${BOLD}Server config file:${NC} /etc/proxyebator/server.conf\n"
    printf "\n"
    printf "  ${YELLOW}Note: The trailing slash in the URL is required.${NC}\n"
}
```

Remove the chisel-specific "socks not R:socks" note since it doesn't apply to wstunnel.

**13. Update client_main and client_run for wstunnel client support.**

Add a `--tunnel` flag to client mode by checking CLIENT_TUNNEL_TYPE (passed via --tunnel flag in client mode). Add wstunnel client download and run functions:

In client_main, after client_collect_params, add tunnel type detection:
```bash
client_main() {
    detect_arch
    detect_client_os
    client_collect_params

    # Determine tunnel type for client
    CLIENT_TUNNEL_TYPE="${TUNNEL_TYPE:-chisel}"

    if [[ "${CLIENT_TUNNEL_TYPE}" == "wstunnel" ]]; then
        client_download_wstunnel
    else
        client_download_chisel
    fi
    client_check_socks_port
    if [[ "${CLIENT_TUNNEL_TYPE}" == "wstunnel" ]]; then
        client_run_wstunnel
    else
        client_run
    fi
}
```

Add client_download_wstunnel (mirrors client_download_chisel but for wstunnel):
```bash
client_download_wstunnel() {
    local install_dir

    if command -v wstunnel &>/dev/null; then
        log_info "wstunnel already installed: $(wstunnel --version 2>&1 | head -1)"
        WSTUNNEL_BIN="$(command -v wstunnel)"
        return
    fi

    if [[ -w "/usr/local/bin" ]]; then
        install_dir="/usr/local/bin"
    else
        install_dir="${HOME}/.local/bin"
        mkdir -p "$install_dir"
        case ":${PATH}:" in
            *":${install_dir}:"*) ;;
            *) log_warn "${install_dir} is not in PATH — add: export PATH=\"\$PATH:${install_dir}\"" ;;
        esac
    fi

    local WSTUNNEL_FALLBACK_VER="v10.5.2"
    local WSTUNNEL_VER
    WSTUNNEL_VER=$(curl -sf --max-time 10 \
        "https://api.github.com/repos/erebe/wstunnel/releases/latest" \
        | grep -o '"tag_name": "[^"]*"' | grep -o 'v[0-9.]*') \
        || WSTUNNEL_VER=""

    if [[ -z "$WSTUNNEL_VER" ]]; then
        log_warn "GitHub API unavailable — using fallback version ${WSTUNNEL_FALLBACK_VER}"
        WSTUNNEL_VER="$WSTUNNEL_FALLBACK_VER"
    fi

    # Determine OS name for asset URL
    local os_name="${CLIENT_OS}"
    # wstunnel uses "linux" and "darwin" in asset names (same as our CLIENT_OS)

    local download_url="https://github.com/erebe/wstunnel/releases/download/${WSTUNNEL_VER}/wstunnel_${WSTUNNEL_VER#v}_${os_name}_${ARCH}.tar.gz"
    log_info "Downloading wstunnel ${WSTUNNEL_VER} for ${CLIENT_OS}/${ARCH}..."

    curl -fLo /tmp/wstunnel_client.tar.gz "$download_url" \
        || die "Failed to download wstunnel from ${download_url}"
    tar -xzf /tmp/wstunnel_client.tar.gz -C /tmp/ wstunnel \
        || die "Failed to extract wstunnel binary from tarball"
    rm -f /tmp/wstunnel_client.tar.gz
    chmod +x /tmp/wstunnel

    if [[ "${CLIENT_OS}" == "darwin" ]]; then
        xattr -d com.apple.quarantine /tmp/wstunnel 2>/dev/null || true
        log_info "macOS: quarantine attribute removed from binary"
    fi

    mv /tmp/wstunnel "${install_dir}/wstunnel"

    "${install_dir}/wstunnel" --version \
        || die "wstunnel binary not working after install"
    log_info "wstunnel installed at ${install_dir}/wstunnel: $("${install_dir}/wstunnel" --version 2>&1 | head -1)"

    WSTUNNEL_BIN="${install_dir}/wstunnel"
}
```

Add client_run_wstunnel:
```bash
client_run_wstunnel() {
    # wstunnel SOCKS5 is client-side: -L socks5://127.0.0.1:PORT
    # Server is just a WebSocket relay, no server-side auth needed
    local wstunnel_url="wss://${CLIENT_HOST}:${CLIENT_PORT}${CLIENT_PATH}"

    client_print_gui_instructions

    log_info "Запуск wstunnel клиента... (Ctrl+C для остановки)"
    printf "\n"

    local wstunnel_bin="${WSTUNNEL_BIN:-wstunnel}"
    exec "${wstunnel_bin}" client \
        -L "socks5://127.0.0.1:${SOCKS_PORT}" \
        --connection-min-idle 5 \
        "${wstunnel_url}"
}
```

Note: wstunnel client does NOT need --auth or user/pass. The secret path in the URL is the only auth.

**14b. Make CLIENT_PASS optional for wstunnel in client_collect_interactive.**

In `client_collect_interactive()`, wrap the password prompt and validation with a TUNNEL_TYPE guard:
```bash
# Only require password for chisel (wstunnel uses path-based auth)
if [[ "${TUNNEL_TYPE:-chisel}" != "wstunnel" ]]; then
    printf "${CYAN}[?]${NC} Пароль: "
    read -r CLIENT_PASS
    [[ -n "$CLIENT_PASS" ]] || die "Пароль обязателен"
fi
```

Also update the non-interactive stdin guard at the top of `client_collect_interactive` to not require CLIENT_PASS for wstunnel:
```bash
if [[ ! -t 0 ]]; then
    if [[ "${TUNNEL_TYPE:-chisel}" == "wstunnel" ]]; then
        [[ -n "${CLIENT_HOST:-}" && -n "${CLIENT_PATH:-}" ]] \
            || die "Non-interactive mode: --host and --path required for wstunnel"
    else
        [[ -n "${CLIENT_HOST:-}" && -n "${CLIENT_PATH:-}" && -n "${CLIENT_PASS:-}" ]] \
            || die "Non-interactive mode: --host, --path, --pass required"
    fi
fi
```

Also in `server_print_connection_info`, for wstunnel mode show only flag-mode client command (no URL mode since wstunnel URLs have no user:pass component):
```bash
printf "  ./proxyebator.sh client --host %s --port %s --path /%s/ --tunnel wstunnel\n" \
    "${DOMAIN}" "${LISTEN_PORT}" "${SECRET_PATH}"
```

**14. Handle --tunnel flag in client mode in CLI parser.**

The --tunnel flag already exists in the while+case parser (line ~1488) and sets TUNNEL_TYPE. It works for both server and client mode already. No change needed here.

**CRITICAL ANTI-PATTERNS TO AVOID (from research):**
- Do NOT use `--restrict-http-upgrade-path-prefix` with nginx. The nginx location block IS the auth.
- wstunnel binary is always `wstunnel` (not `wstunnel-cli`).
- wstunnel uses `.tar.gz` (not `.gz` like chisel) — use `tar -xzf`, never `gunzip`.
- wstunnel SOCKS5 is client-side only via `-L socks5://` — server has NO SOCKS5 flag.
  </action>
  <verify>
1. `bash -n proxyebator.sh` exits 0 (syntax check).
2. `grep -c 'server_download_wstunnel\|server_create_systemd_wstunnel\|client_download_wstunnel\|client_run_wstunnel' proxyebator.sh` returns 4+ (all new functions exist).
3. `grep 'TUNNEL_PORT' proxyebator.sh | grep -c '7778'` returns 1+ (wstunnel port referenced).
4. `grep -c 'wstunnel' proxyebator.sh` returns 30+ (wstunnel integration is pervasive).
5. `grep 'restrict-http-upgrade-path-prefix' proxyebator.sh` returns nothing (anti-pattern avoided).
6. `grep 'tar -xzf' proxyebator.sh` returns 2+ matches (server and client wstunnel download).
  </verify>
  <done>
- proxyebator.sh syntax-checks clean with `bash -n`
- server_collect_params prompts for tunnel type (chisel/wstunnel)
- server_download_wstunnel downloads from GitHub with .tar.gz extraction
- server_create_systemd_wstunnel creates unit with `wstunnel server ws://127.0.0.1:7778`
- server_main branches on TUNNEL_TYPE for download/systemd
- generate_tunnel_location_block uses TUNNEL_PORT variable (7778 for wstunnel, 7777 for chisel)
- server_configure_firewall uses TUNNEL_PORT (not hardcoded 7777)
- server_save_config writes correct TUNNEL_TYPE and TUNNEL_PORT
- _uninstall_binary removes wstunnel when TUNNEL_TYPE=wstunnel
- _uninstall_firewall uses TUNNEL_PORT from server.conf
- server_print_connection_info shows wstunnel client command when appropriate
- client_main branches on TUNNEL_TYPE for wstunnel client download and launch
- client_run_wstunnel uses exec with `-L socks5://127.0.0.1:PORT`
  </done>
</task>

</tasks>

<verification>
1. `bash -n proxyebator.sh` passes (no syntax errors).
2. All existing chisel functionality is preserved (no regressions).
3. wstunnel code paths are present and structurally correct.
4. No anti-patterns: no `--restrict-http-upgrade-path-prefix`, no `gunzip` for wstunnel, no hardcoded 7777 in shared functions.
5. TUNNEL_PORT is used consistently in firewall, nginx, verify, and uninstall.
</verification>

<success_criteria>
1. `bash -n proxyebator.sh` exits 0
2. `grep -c 'wstunnel' proxyebator.sh` >= 30
3. No hardcoded 7777 remains in shared functions (firewall, uninstall, nginx location) — all use TUNNEL_PORT
4. server_download_wstunnel, server_create_systemd_wstunnel, client_download_wstunnel, client_run_wstunnel functions all exist
5. server_main has TUNNEL_TYPE conditional branching
</success_criteria>

<output>
After completion, create `.planning/phases/06-wstunnel-backend-and-readme/06-01-SUMMARY.md`
</output>
