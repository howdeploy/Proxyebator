---
phase: 01-script-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - SCRIPT-01
  - SCRIPT-05

must_haves:
  truths:
    - "Running ./proxyebator.sh with no arguments prints usage showing server, client, uninstall commands"
    - "Running ./proxyebator.sh --help prints the same usage"
    - "Running ./proxyebator.sh unknown-cmd prints usage and exits non-zero"
    - "Colored log output (green INFO, yellow WARN, red FAIL) is visible when stdout is a terminal"
    - "ANSI codes are suppressed when stdout is not a terminal (e.g., piped to a file)"
  artifacts:
    - path: "proxyebator.sh"
      provides: "Executable bash script skeleton with dispatcher, logging, and usage"
      contains: "set -euo pipefail"
      min_lines: 80
  key_links:
    - from: "proxyebator.sh CLI parser (bottom)"
      to: "server_main / client_main / uninstall_main functions"
      via: "case $MODE dispatch"
      pattern: "case.*MODE.*server.*server_main"
    - from: "ANSI color constants"
      to: "log_info / log_warn / die functions"
      via: "printf with $GREEN/$YELLOW/$RED/$NC"
      pattern: "\\$\\{GREEN\\}|\\$\\{RED\\}|\\$\\{YELLOW\\}"
---

<objective>
Create the executable bash script skeleton: shebang, safety flags, ANSI color constants with terminal detection, colored logging functions (log_info, log_warn, die), print_usage, stub mode functions, and the CLI parser/dispatcher at the bottom.

Purpose: Every subsequent phase hangs its code onto this skeleton. Getting the structure right now — single entry point at bottom, functions defined above, terminal-gated colors — prevents structural rewrites in later phases.
Output: proxyebator.sh — executable, prints usage when run with no args or --help, exits cleanly.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-script-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create script skeleton with logging infrastructure</name>
  <files>proxyebator.sh</files>
  <action>
Create /home/kosya/vibecoding/proxyebator/proxyebator.sh with this exact structure (top to bottom):

1. Shebang: `#!/bin/bash`
   Rationale: Target is standard VPS installs where bash is always at /bin/bash; no need for env indirection.

2. Safety flags immediately after shebang:
   ```bash
   set -euo pipefail
   ```

3. ANSI color constants with terminal detection:
   ```bash
   if [[ -t 1 ]]; then
       RED='\033[0;31m'
       YELLOW='\033[0;33m'
       GREEN='\033[0;32m'
       CYAN='\033[0;36m'
       BOLD='\033[1m'
       NC='\033[0m'
   else
       RED='' YELLOW='' GREEN='' CYAN='' BOLD='' NC=''
   fi
   readonly RED YELLOW GREEN CYAN BOLD NC
   ```
   Rationale: `[[ -t 1 ]]` checks if stdout is a terminal — authoritative check; do NOT use `$TERM`. `readonly` prevents accidental mutation in functions.

4. Logging functions (use `printf`, never `echo -e`):
   ```bash
   log_info() { printf "${GREEN}[INFO]${NC} %s\n" "$*"; }
   log_warn() { printf "${YELLOW}[WARN]${NC} %s\n" "$*" >&2; }
   die()      { printf "${RED}[FAIL]${NC} %s\n" "$*" >&2; exit 1; }
   ```
   Rationale: log_warn and die go to stderr so they're visible when stdout is redirected.

5. print_usage function:
   ```bash
   print_usage() {
       cat << EOF
   ${BOLD}proxyebator${NC} — WebSocket proxy tunnel installer

   ${BOLD}USAGE${NC}
     $(basename "$0") <command> [options]

   ${BOLD}COMMANDS${NC}
     server      Install and configure proxy server (nginx + Chisel/wstunnel + TLS)
     client      Install tunnel client binary and configure SOCKS5
     uninstall   Remove all installed components

   ${BOLD}OPTIONS${NC}
     --help, -h          Show this help
     --domain DOMAIN     Server domain name (skips interactive prompt)
     --tunnel TYPE       Tunnel backend: chisel (default) or wstunnel
     --port PORT         Listen port (default: 443)
     --masquerade MODE   Cover site mode: stub | proxy | static (default: stub)

   ${BOLD}EXAMPLES${NC}
     # Interactive install
     sudo $(basename "\$0") server

     # Non-interactive install (AI-agent friendly)
     sudo $(basename "\$0") server --domain example.com --tunnel chisel

     # Connect client
     sudo $(basename "\$0") client

     # Uninstall
     sudo $(basename "\$0") uninstall
   EOF
   }
   ```

6. Stub mode functions (to be filled in by later phases/plans):
   ```bash
   server_main() {
       log_info "server_main: not yet implemented"
   }

   client_main() {
       log_info "client_main: not yet implemented"
   }

   uninstall_main() {
       log_info "uninstall_main: not yet implemented"
   }
   ```

7. Entry point at bottom — CLI parser then mode dispatch:
   ```bash
   # ── ENTRY POINT ──────────────────────────────────────────────────────────
   MODE=""

   # No args: print usage and exit cleanly
   if [[ $# -eq 0 ]]; then
       print_usage
       exit 0
   fi

   # Extract positional mode (first arg)
   case "$1" in
       server|client|uninstall) MODE="$1"; shift ;;
       --help|-h) print_usage; exit 0 ;;
       *) print_usage; die "Unknown command: $1" ;;
   esac

   # Parse remaining flags (non-interactive mode support — values used by Phase 2+)
   DOMAIN=""
   TUNNEL_TYPE=""
   LISTEN_PORT=""
   MASQUERADE_MODE=""

   while [[ $# -gt 0 ]]; do
       case "$1" in
           --help|-h)    print_usage; exit 0 ;;
           --domain)     DOMAIN="${2:-}"; shift 2 ;;
           --tunnel)     TUNNEL_TYPE="${2:-}"; shift 2 ;;
           --port)       LISTEN_PORT="${2:-}"; shift 2 ;;
           --masquerade) MASQUERADE_MODE="${2:-}"; shift 2 ;;
           *) die "Unknown option: $1" ;;
       esac
   done

   # Dispatch to mode function
   case "$MODE" in
       server)    server_main ;;
       client)    client_main ;;
       uninstall) uninstall_main ;;
   esac
   ```

After writing the file, make it executable:
```bash
chmod +x proxyebator.sh
```

IMPORTANT — ordering rules (from research pitfall #4):
- ALL function definitions (log_info, die, print_usage, server_main, client_main, uninstall_main) MUST appear ABOVE the entry point block
- The entry point (case dispatcher) MUST be the last thing in the file
- Do NOT split functions and entry point into separate sections that break this order
  </action>
  <verify>
Run these commands from /home/kosya/vibecoding/proxyebator/:
```bash
# 1. No args → usage
./proxyebator.sh
# Expected: prints usage with COMMANDS section showing server, client, uninstall

# 2. --help flag
./proxyebator.sh --help
# Expected: same usage output

# 3. Unknown command → usage + FAIL message, non-zero exit
./proxyebator.sh badcmd; echo "exit: $?"
# Expected: usage printed, then [FAIL] Unknown command: badcmd, exit: 1

# 4. Valid mode → stub message
./proxyebator.sh server
# Expected: [INFO] server_main: not yet implemented

# 5. Non-terminal color suppression
./proxyebator.sh server 2>&1 | cat | grep -c '\\033'
# Expected: 0 (no raw ANSI escape codes in piped output)
```
  </verify>
  <done>
- proxyebator.sh exists and is executable (chmod +x applied)
- Running with no args prints usage showing server, client, uninstall
- Running --help prints the same usage
- Running an unknown command prints usage and exits with code 1
- Running a valid mode (server/client/uninstall) prints the stub log_info message
- Piped output contains no raw ANSI escape sequences
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/kosya/vibecoding/proxyebator

# Verify file exists and is executable
test -x proxyebator.sh && echo "OK: executable" || echo "FAIL: not executable"

# Verify safety flags present
grep -q 'set -euo pipefail' proxyebator.sh && echo "OK: set -euo pipefail" || echo "FAIL: missing safety flags"

# Verify terminal detection pattern present
grep -q '\-t 1' proxyebator.sh && echo "OK: terminal detection" || echo "FAIL: missing -t 1"

# Verify readonly on color constants
grep -q 'readonly RED' proxyebator.sh && echo "OK: readonly colors" || echo "FAIL: missing readonly"

# Verify printf not echo -e for logging
grep -q 'echo -e' proxyebator.sh && echo "FAIL: uses echo -e" || echo "OK: no echo -e"

# Verify all three modes dispatch
grep -q 'server_main' proxyebator.sh && echo "OK: server_main" || echo "FAIL"
grep -q 'client_main' proxyebator.sh && echo "OK: client_main" || echo "FAIL"
grep -q 'uninstall_main' proxyebator.sh && echo "OK: uninstall_main" || echo "FAIL"

# Functional test: no args exits 0
./proxyebator.sh; echo "exit_noargs: $?"

# Functional test: bad command exits 1
./proxyebator.sh badcmd 2>/dev/null; echo "exit_badcmd: $?"
```
</verification>

<success_criteria>
- proxyebator.sh exists, is executable, passes `bash -n proxyebator.sh` (no syntax errors)
- No-args run: exits 0, prints usage with server/client/uninstall
- --help: exits 0, same usage
- Unknown command: exits 1, prints [FAIL] message
- Valid modes (server, client, uninstall): exits 0, prints stub [INFO] message
- Piped output has no raw ANSI codes
- set -euo pipefail present as first non-comment line after shebang
- readonly applied to all ANSI color constants
- No echo -e anywhere in the file
</success_criteria>

<output>
After completion, create .planning/phases/01-script-foundation/01-01-SUMMARY.md with:
- What was built (file created, line count)
- Key structural decisions made (why entry point at bottom, why printf not echo -e)
- Patterns established for future plans to follow
- Verification results
</output>
