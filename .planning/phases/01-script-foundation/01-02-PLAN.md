---
phase: 01-script-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - SCRIPT-02
  - SCRIPT-03

must_haves:
  truths:
    - "Running ./proxyebator.sh server on Debian/Ubuntu prints the detected OS name and package manager"
    - "Running ./proxyebator.sh server on CentOS/Fedora/Arch prints the detected OS and package manager"
    - "Running ./proxyebator.sh server prints detected CPU architecture (amd64 or arm64)"
    - "Running ./proxyebator.sh server generates and prints a 32-char hex secret WS path"
    - "Running ./proxyebator.sh server generates and prints a 32-char base64 auth token"
    - "Running ./proxyebator.sh server as non-root user prints a clear error and exits non-zero"
  artifacts:
    - path: "proxyebator.sh"
      provides: "detect_os, detect_arch, check_root, gen_secret_path, gen_auth_token, wired server_main"
      contains: "detect_os"
      min_lines: 180
  key_links:
    - from: "server_main"
      to: "check_root / detect_os / detect_arch"
      via: "direct function calls at start of server_main"
      pattern: "server_main.*check_root|check_root.*detect_os"
    - from: "detect_os"
      to: "/etc/os-release"
      via: "source /etc/os-release"
      pattern: "source /etc/os-release"
    - from: "gen_secret_path"
      to: "openssl rand -hex 16"
      via: "command substitution"
      pattern: "openssl rand -hex 16"
    - from: "gen_auth_token"
      to: "openssl rand -base64 24 | tr -d '\\n'"
      via: "command substitution with pipe"
      pattern: "openssl rand -base64 24.*tr -d"
---

<objective>
Extend proxyebator.sh with OS detection (detect_os), arch detection (detect_arch), root check (check_root), and secret generation functions (gen_secret_path, gen_auth_token). Wire server_main to call all of these and print the results.

Purpose: Phase 2 needs detect_os to know which package manager to call, detect_arch to pick the correct binary download URL, and gen_secret_path/gen_auth_token to write the config file. All must be correct and tested before Phase 2 builds on top of them.
Output: proxyebator.sh with all detection + generation functions implemented; server mode prints OS, arch, and generated secrets.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-script-foundation/01-RESEARCH.md
@.planning/phases/01-script-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detection and secret generation functions</name>
  <files>proxyebator.sh</files>
  <action>
Read the current proxyebator.sh from /home/kosya/vibecoding/proxyebator/proxyebator.sh first.

Insert these four functions ABOVE the stub mode functions (server_main, client_main, uninstall_main) and BELOW the print_usage function. Preserve the entry point block at the bottom — do not move it.

**check_root function:**
```bash
check_root() {
    if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
        die "This script must be run as root. Use: sudo $(basename "$0") $*"
    fi
}
```
Rationale: `${EUID:-$(id -u)}` handles rare shells where EUID is not set.

**detect_os function:**
```bash
detect_os() {
    [[ -f /etc/os-release ]] || die "Cannot detect OS: /etc/os-release not found"
    # shellcheck disable=SC1091
    source /etc/os-release

    _map_os_id() {
        case "$1" in
            debian|ubuntu|raspbian)
                PKG_UPDATE="apt-get update -qq"
                PKG_INSTALL="apt-get install -y -qq"
                NGINX_CONF_DIR="/etc/nginx/sites-available"
                NGINX_CONF_LINK="/etc/nginx/sites-enabled"
                ;;
            centos|rhel|almalinux|rocky)
                PKG_UPDATE="dnf check-update || true"
                PKG_INSTALL="dnf install -y"
                NGINX_CONF_DIR="/etc/nginx/conf.d"
                NGINX_CONF_LINK=""
                ;;
            fedora)
                PKG_UPDATE="dnf check-update || true"
                PKG_INSTALL="dnf install -y"
                NGINX_CONF_DIR="/etc/nginx/conf.d"
                NGINX_CONF_LINK=""
                ;;
            arch|manjaro)
                PKG_UPDATE="pacman -Sy --noconfirm"
                PKG_INSTALL="pacman -S --needed --noconfirm"
                NGINX_CONF_DIR="/etc/nginx/sites-available"
                NGINX_CONF_LINK="/etc/nginx/sites-enabled"
                ;;
            *) return 1 ;;
        esac
        return 0
    }

    OS="$ID"
    if ! _map_os_id "$ID"; then
        # Fallback: check ID_LIKE for derivative distros (Mint, Pop!_OS, etc.)
        local like_id
        like_id=$(printf '%s' "${ID_LIKE:-}" | awk '{print $1}')
        OS="$like_id"
        if ! _map_os_id "$like_id"; then
            die "Unsupported OS: ${PRETTY_NAME:-$ID}. Supported: Debian, Ubuntu, CentOS, Fedora, Arch"
        fi
    fi

    log_info "Detected OS: ${PRETTY_NAME:-$ID} | Package manager: $(printf '%s' "$PKG_INSTALL" | awk '{print $1}')"
}
```

Important notes on detect_os:
- ALWAYS check `[[ -f /etc/os-release ]]` before sourcing — set -u will crash otherwise
- Use `printf '%s' "${ID_LIKE:-}"` not `echo "${ID_LIKE:-}"` to avoid issues with special chars
- `$ID_LIKE` can be space-separated (e.g. "ubuntu debian") — take first token only via awk
- `NGINX_CONF_LINK` is set to empty string for conf.d-based distros (no symlink needed there)
- All variables (OS, PKG_UPDATE, PKG_INSTALL, NGINX_CONF_DIR, NGINX_CONF_LINK) become globals

**detect_arch function:**
```bash
detect_arch() {
    local machine
    machine="$(uname -m)"
    case "$machine" in
        x86_64|amd64)  ARCH="amd64" ;;
        aarch64|arm64) ARCH="arm64" ;;
        armv7l|armv6l) ARCH="arm"   ;;
        *)
            die "Unsupported architecture: $machine. Supported: amd64 (x86_64), arm64 (aarch64)"
            ;;
    esac
    log_info "Detected architecture: $ARCH"
}
```
Rationale: uname returns "x86_64" but Go/Chisel/wstunnel release filenames use "amd64" — must map. See research pitfall #7.

**gen_secret_path function:**
```bash
gen_secret_path() {
    # 32 hex chars = 128 bits entropy
    # openssl rand -hex 16 produces exactly 32 hex characters
    openssl rand -hex 16
}
```

**gen_auth_token function:**
```bash
gen_auth_token() {
    # openssl rand -base64 24 = 24 bytes → 32 base64 chars
    # tr -d '\n' removes trailing newline (pitfall #5 — always strip newline)
    openssl rand -base64 24 | tr -d '\n'
}
```
Rationale: Per user locked decision. `tr -d '\n'` is mandatory — without it token is 33 chars including newline, causing auth failures later.
  </action>
  <verify>
```bash
# Syntax check
bash -n /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: no syntax errors"

# Check functions are present
grep -q 'detect_os'       /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: detect_os"
grep -q 'detect_arch'     /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: detect_arch"
grep -q 'check_root'      /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: check_root"
grep -q 'gen_secret_path' /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: gen_secret_path"
grep -q 'gen_auth_token'  /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: gen_auth_token"

# Check openssl commands with correct flags
grep -q 'openssl rand -hex 16'            /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: hex generation"
grep -q 'openssl rand -base64 24'         /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: base64 generation"
grep -q "tr -d '\\\\n'"                   /home/kosya/vibecoding/proxyebator/proxyebator.sh && echo "OK: newline stripped"

# Verify secret lengths locally
SECRET=$(openssl rand -hex 16)
echo "Secret path length: ${#SECRET} (expected: 32)"
TOKEN=$(openssl rand -base64 24 | tr -d '\n')
echo "Auth token length: ${#TOKEN} (expected: 32)"
```
  </verify>
  <done>
- detect_os, detect_arch, check_root, gen_secret_path, gen_auth_token functions exist in proxyebator.sh
- All functions defined ABOVE entry point at bottom of file
- bash -n passes with no syntax errors
- gen_secret_path uses `openssl rand -hex 16` (per locked decision)
- gen_auth_token uses `openssl rand -base64 24 | tr -d '\n'` (per locked decision)
- detect_os checks /etc/os-release existence before sourcing
- detect_arch maps x86_64 to amd64 and aarch64 to arm64
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire server_main to call detection and print secrets</name>
  <files>proxyebator.sh</files>
  <action>
Replace the stub server_main function with the working Phase 1 implementation. Read the file first to confirm current state of server_main.

Replace:
```bash
server_main() {
    log_info "server_main: not yet implemented"
}
```

With:
```bash
server_main() {
    check_root
    detect_os
    detect_arch

    local secret_path auth_token
    secret_path="$(gen_secret_path)"
    auth_token="$(gen_auth_token)"

    log_info "Generated secret WS path: /${secret_path}"
    log_info "Generated auth token:      ${auth_token}"
    log_warn "Phase 1 skeleton: no packages installed, no services configured yet."
}
```

Leave client_main and uninstall_main as stubs — they are Phase 4 and Phase 5 work respectively.

Verify the entry point block at the bottom is UNCHANGED — no modifications to the CLI parser section.
  </action>
  <verify>
```bash
# Run server mode as root (or check the root check fires correctly as non-root)
# If running as non-root, we verify the root check message:
sudo /home/kosya/vibecoding/proxyebator/proxyebator.sh server 2>&1 | head -20
# Expected output lines (in order):
# [INFO] Detected OS: <distro name> | Package manager: apt-get (or dnf/pacman)
# [INFO] Detected architecture: amd64 (or arm64)
# [INFO] Generated secret WS path: /<32 hex chars>
# [INFO] Generated auth token:      <32 base64 chars>
# [WARN] Phase 1 skeleton: no packages installed...

# Verify secret path length
sudo /home/kosya/vibecoding/proxyebator/proxyebator.sh server 2>&1 | grep "secret WS path" | grep -oP '/[0-9a-f]+' | awk '{print length($0)-1}'
# Expected: 32

# Verify auth token length
sudo /home/kosya/vibecoding/proxyebator/proxyebator.sh server 2>&1 | grep "auth token" | awk '{print $NF}' | tr -d '\n' | wc -c
# Expected: 32

# Verify non-root check fires
/home/kosya/vibecoding/proxyebator/proxyebator.sh server 2>&1 | grep -q "root" && echo "OK: root check fires" || echo "FAIL: no root check"

# Verify entry point still works after changes
/home/kosya/vibecoding/proxyebator/proxyebator.sh --help | grep -q "server" && echo "OK: help still works"
/home/kosya/vibecoding/proxyebator/proxyebator.sh client 2>&1 | grep -q "client_main" && echo "OK: client stub still works"
```
  </verify>
  <done>
- server_main calls check_root, detect_os, detect_arch in that order
- server_main generates and logs secret_path (32 hex chars) and auth_token (32 base64 chars)
- Running as non-root: script prints [FAIL] root message and exits 1
- Running as root: OS/arch detection output appears, then both secrets are printed
- client_main and uninstall_main remain as stubs (Phase 4/5 work)
- CLI parser and --help remain fully functional
  </done>
</task>

</tasks>

<verification>
Run the full Phase 1 acceptance test suite:

```bash
cd /home/kosya/vibecoding/proxyebator

# --- Structural checks ---
bash -n proxyebator.sh && echo "PASS: syntax OK"
grep -c 'set -euo pipefail' proxyebator.sh | grep -q 1 && echo "PASS: safety flags"
grep -q 'readonly RED' proxyebator.sh && echo "PASS: readonly colors"
grep -q '\-t 1' proxyebator.sh && echo "PASS: terminal detection"

# --- Requirement SCRIPT-01: modes dispatch ---
./proxyebator.sh 2>&1 | grep -q 'server' && echo "PASS: usage shows server"
./proxyebator.sh 2>&1 | grep -q 'client' && echo "PASS: usage shows client"
./proxyebator.sh 2>&1 | grep -q 'uninstall' && echo "PASS: usage shows uninstall"

# --- Requirement SCRIPT-05: colored logging ---
# Colors present when terminal (will show colors in terminal session)
./proxyebator.sh client 2>&1 | grep -q 'client_main' && echo "PASS: log_info works"

# --- Requirements SCRIPT-02, SCRIPT-03, secret gen: server mode ---
sudo ./proxyebator.sh server 2>&1 | grep -q 'Detected OS' && echo "PASS: SCRIPT-02 OS detection"
sudo ./proxyebator.sh server 2>&1 | grep -q 'Detected architecture' && echo "PASS: SCRIPT-03 arch detection"
sudo ./proxyebator.sh server 2>&1 | grep -q 'secret WS path' && echo "PASS: secret path generated"
sudo ./proxyebator.sh server 2>&1 | grep -q 'auth token' && echo "PASS: auth token generated"
```
</verification>

<success_criteria>
All 4 requirements covered:
- SCRIPT-01: script exists, modes server/client/uninstall dispatch correctly
- SCRIPT-02: detect_os identifies OS from /etc/os-release with ID_LIKE fallback
- SCRIPT-03: detect_arch maps uname -m to amd64/arm64
- SCRIPT-05: log_info/log_warn/die with terminal-gated ANSI colors

Phase 1 success criteria (from ROADMAP.md) all TRUE:
1. ./proxyebator.sh without args prints usage showing server, client, uninstall
2. Server mode identifies Debian/Ubuntu (current dev machine) and prints OS + package manager
3. Server mode detects and prints amd64 or arm64
4. Colored [INFO]/[WARN]/[FAIL] messages visible in terminal, suppressed when piped
5. ./proxyebator.sh server generates and prints 32-char hex path and 32-char base64 token
</success_criteria>

<output>
After completion, create .planning/phases/01-script-foundation/01-02-SUMMARY.md with:
- Functions implemented (list with brief description)
- Verification results for each ROADMAP success criterion
- Global variables established for Phase 2 (OS, PKG_INSTALL, PKG_UPDATE, ARCH, NGINX_CONF_DIR, NGINX_CONF_LINK)
- Any deviations from the research patterns and why
</output>
