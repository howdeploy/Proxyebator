---
phase: 04-client-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - CLI-02
  - CLI-03

must_haves:
  truths:
    - "Running `./proxyebator.sh client wss://user:pass@host:443/path/` parses all 5 components (user, pass, host, port, path) without prompting"
    - "Running `./proxyebator.sh client --host x --port 443 --path /abc/ --pass secret` sets all params without prompting"
    - "Running `./proxyebator.sh client` with no args enters interactive mode and prompts for each missing param"
    - "detect_client_os() sets CLIENT_OS to 'linux' on Linux/WSL and 'darwin' on macOS"
    - "--socks-port flag is accepted and stored in CLIENT_SOCKS_PORT"
  artifacts:
    - path: "proxyebator.sh"
      provides: "Client parameter collection: URL parsing, CLI flags, interactive prompts, OS detection"
      contains: "client_collect_params"
  key_links:
    - from: "CLI entry point (while+case parser)"
      to: "client_collect_params()"
      via: "Global variables CLIENT_HOST, CLIENT_PORT, CLIENT_PATH, CLIENT_PASS, CLIENT_USER, CLIENT_SOCKS_PORT, CLIENT_URL"
      pattern: "CLIENT_HOST|CLIENT_PORT|CLIENT_PATH|CLIENT_PASS"
---

<objective>
Implement client-mode parameter collection: extend CLI parser for client flags, add URL parsing, CLI flag collection, and interactive prompts. Add cross-platform OS detection for client (Linux vs macOS).

Purpose: Client mode needs connection parameters (host, port, secret path, password) collected via three input modes before it can download the binary and connect. This plan builds the parameter collection layer that Plan 02 consumes.

Output: proxyebator.sh with working client_collect_params(), detect_client_os(), and extended CLI parser.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-client-mode/04-RESEARCH.md
@proxyebator.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CLI parser and add client global variables</name>
  <files>proxyebator.sh</files>
  <action>
  1. Add client-mode global variable declarations alongside existing DOMAIN/TUNNEL_TYPE/LISTEN_PORT/MASQUERADE_MODE block (after `MASQUERADE_MODE=""`):

  ```bash
  CLIENT_HOST=""
  CLIENT_PORT=""
  CLIENT_PATH=""
  CLIENT_PASS=""
  CLIENT_USER=""
  CLIENT_SOCKS_PORT=""
  CLIENT_URL=""
  ```

  2. After the mode extraction `case "$1" in` block and before the while loop, add URL positional argument detection for client mode:

  ```bash
  # Capture positional wss:// URL for client mode (before flag parsing)
  if [[ "$MODE" == "client" && $# -gt 0 && "$1" =~ ^(wss|https):// ]]; then
      CLIENT_URL="$1"
      shift
  fi
  ```

  3. Extend the existing `while [[ $# -gt 0 ]]` flag parser to accept client-mode flags. Add these cases BEFORE the `*) die "Unknown option: $1"` fallback:

  ```bash
  --host)       CLIENT_HOST="${2:-}"; shift 2 ;;
  --port)       CLIENT_PORT="${2:-}"; shift 2 ;;
  --path)       CLIENT_PATH="${2:-}"; shift 2 ;;
  --pass)       CLIENT_PASS="${2:-}"; shift 2 ;;
  --socks-port) CLIENT_SOCKS_PORT="${2:-}"; shift 2 ;;
  ```

  NOTE: --port already exists as an alias for LISTEN_PORT in server mode. The new --port case for client must coexist. Handle this by making --port set LISTEN_PORT for server mode and CLIENT_PORT for client mode:
  - Remove the existing `--port) LISTEN_PORT=...` line
  - Replace with a mode-aware handler:
  ```bash
  --port)
      if [[ "$MODE" == "client" ]]; then
          CLIENT_PORT="${2:-}"
      else
          LISTEN_PORT="${2:-}"
      fi
      shift 2 ;;
  ```

  4. Update print_usage() to document client-mode options. Add after the existing OPTIONS section, before EXAMPLES:

  ```
  ${BOLD}CLIENT OPTIONS${NC}
    --host HOST         Server hostname
    --port PORT         Server port (default: 443)
    --path PATH         Secret tunnel path
    --pass PASSWORD     Auth password/token
    --socks-port PORT   Local SOCKS5 port (default: 1080)
  ```

  Also update the client example line in EXAMPLES section:
  ```
  # Connect client (URL mode — copy from server output)
  $(basename "$0") client wss://proxyebator:TOKEN@example.com:443/SECRET/

  # Connect client (flag mode)
  $(basename "$0") client --host example.com --port 443 --path /SECRET/ --pass TOKEN
  ```

  Remove `sudo` from the client example (client does not need root).
  </action>
  <verify>Run `bash -n proxyebator.sh` to confirm no syntax errors. Run `bash proxyebator.sh --help` and confirm CLIENT OPTIONS section appears. Run `bash proxyebator.sh client --host test.com --port 2087 --path /abc/ --pass mytoken --socks-port 9050 2>&1 | head -5` and confirm it does NOT die with "Unknown option".</verify>
  <done>CLI parser accepts --host, --port (mode-aware), --path, --pass, --socks-port without error. Client URL positional arg captured in CLIENT_URL. print_usage shows client options.</done>
</task>

<task type="auto">
  <name>Task 2: Implement detect_client_os, URL parser, and client_collect_params orchestrator</name>
  <files>proxyebator.sh</files>
  <action>
  Add the following functions AFTER the detect_arch() function and BEFORE the server parameter collection section.

  1. **detect_client_os()** — Detects Linux vs Darwin for correct Chisel asset naming:

  ```bash
  detect_client_os() {
      local kernel
      kernel="$(uname -s)"
      case "$kernel" in
          Linux)  CLIENT_OS="linux"  ;;
          Darwin) CLIENT_OS="darwin" ;;
          *)      die "Unsupported client OS: ${kernel}. Supported: Linux (including WSL), macOS (Darwin)" ;;
      esac
      log_info "Client OS: ${CLIENT_OS}"
  }
  ```

  2. **client_parse_url()** — Parses wss://user:pass@host:port/path/ into components. Uses sed -E (portable on Linux and macOS). Handles both wss:// and https:// schemes. Default port 443 if omitted. Ensures trailing slash on path. Validates all components extracted.

  Implementation from research Pattern 2 (04-RESEARCH.md). Key points:
  - Extract user: `sed -E 's|wss?://([^:@]*).*|\1|'` (also matches https)
  - Extract pass: `sed -E 's|wss?://[^:@]*:([^@]*)@.*|\1|'`
  - Extract host: `sed -E 's|wss?://[^@]*@([^:/]+).*|\1|'`
  - Port: grep for port pattern, extract or default to 443
  - Path: `sed -E 's|wss?://[^@]*@[^/]*(/.*)|\1|'`
  - Normalize trailing slash
  - Validate all 4 required components (user, pass, host, path) are non-empty or die

  Note: `wss?://` in sed/grep matches both `ws://` and `wss://`. To also match `https://`, use `(wss?|https?)://` or handle https separately. Since the primary format is wss:// and https:// is an alias, use a broader regex: `sed -E 's|(wss?|https?)://([^:@]*).*|\2|'`. Alternatively, normalize the URL to remove scheme prefix first, then parse.

  Simpler approach — strip scheme first:
  ```bash
  client_parse_url() {
      local url="$1"
      # Strip scheme (wss://, ws://, https://, http://)
      local stripped
      stripped="${url#*://}"

      # user:pass@host:port/path
      CLIENT_USER="${stripped%%:*}"
      local after_user="${stripped#*:}"
      CLIENT_PASS="${after_user%%@*}"
      local after_at="${after_user#*@}"
      # host:port/path or host/path
      local host_port_path="$after_at"
      local host_port="${host_port_path%%/*}"
      CLIENT_PATH="/${host_port_path#*/}"

      if [[ "$host_port" == *:* ]]; then
          CLIENT_HOST="${host_port%%:*}"
          CLIENT_PORT="${host_port##*:}"
      else
          CLIENT_HOST="$host_port"
          CLIENT_PORT="443"
      fi

      # Normalize trailing slash
      [[ "$CLIENT_PATH" == */ ]] || CLIENT_PATH="${CLIENT_PATH}/"

      # Validate
      [[ -n "$CLIENT_USER" ]] || die "Could not parse user from URL: $url"
      [[ -n "$CLIENT_PASS" ]] || die "Could not parse password from URL: $url"
      [[ -n "$CLIENT_HOST" ]] || die "Could not parse host from URL: $url"
      [[ -n "$CLIENT_PATH" && "$CLIENT_PATH" != "/" ]] || die "Could not parse path from URL: $url"

      log_info "URL parsed: host=${CLIENT_HOST} port=${CLIENT_PORT} path=${CLIENT_PATH} user=${CLIENT_USER}"
  }
  ```

  This uses pure bash string manipulation (no sed dependency for URL parsing). The `%%` and `##` operators are bash builtins available in bash 3.2+ (macOS compatible).

  3. **client_collect_interactive()** — Prompts for each missing parameter. Only asks for params not already set (from partial CLI flags). Order: host, port, path, password. Defaults: port=443, user=proxyebator. Non-interactive detection: if `[[ ! -t 0 ]]` and any required param is missing, die with helpful message listing required flags.

  ```bash
  client_collect_interactive() {
      # Non-interactive stdin detection
      if [[ ! -t 0 ]]; then
          if [[ -z "${CLIENT_HOST:-}" || -z "${CLIENT_PATH:-}" || -z "${CLIENT_PASS:-}" ]]; then
              die "Non-interactive mode: missing required params. Use: ./proxyebator.sh client --host HOST --path PATH --pass PASS [--port PORT]"
          fi
      fi

      if [[ -z "${CLIENT_HOST:-}" ]]; then
          printf "${CYAN}[?]${NC} Хост сервера (например: example.com): "
          read -r CLIENT_HOST
          [[ -n "$CLIENT_HOST" ]] || die "Хост обязателен"
      fi

      if [[ -z "${CLIENT_PORT:-}" ]]; then
          printf "${CYAN}[?]${NC} Порт сервера [443]: "
          read -r CLIENT_PORT
          CLIENT_PORT="${CLIENT_PORT:-443}"
      fi

      if [[ -z "${CLIENT_PATH:-}" ]]; then
          printf "${CYAN}[?]${NC} Секретный путь (например: /abc123/): "
          read -r CLIENT_PATH
          [[ -n "$CLIENT_PATH" ]] || die "Путь обязателен"
          # Normalize: ensure leading and trailing slashes
          [[ "$CLIENT_PATH" == /* ]] || CLIENT_PATH="/${CLIENT_PATH}"
          [[ "$CLIENT_PATH" == */ ]] || CLIENT_PATH="${CLIENT_PATH}/"
      fi

      if [[ -z "${CLIENT_PASS:-}" ]]; then
          printf "${CYAN}[?]${NC} Пароль (токен авторизации): "
          read -r CLIENT_PASS
          [[ -n "$CLIENT_PASS" ]] || die "Пароль обязателен"
      fi

      # Default user to "proxyebator" (server always uses this)
      CLIENT_USER="${CLIENT_USER:-proxyebator}"
  }
  ```

  4. **client_collect_params()** — Orchestrator that calls the right collection method based on input mode priority:

  ```bash
  client_collect_params() {
      if [[ -n "${CLIENT_URL:-}" ]]; then
          # Mode 1: URL string (highest priority)
          client_parse_url "$CLIENT_URL"
      elif [[ -n "${CLIENT_HOST:-}" || -n "${CLIENT_PASS:-}" ]]; then
          # Mode 2: CLI flags (at least one flag set)
          CLIENT_PORT="${CLIENT_PORT:-443}"
          CLIENT_USER="${CLIENT_USER:-proxyebator}"
          # Fill in any missing params via interactive
          client_collect_interactive
      else
          # Mode 3: Full interactive
          client_collect_interactive
      fi

      log_info "Connection params: host=${CLIENT_HOST} port=${CLIENT_PORT} path=${CLIENT_PATH}"
  }
  ```

  5. **Wire into client_main()** — Replace the stub:

  ```bash
  client_main() {
      detect_arch
      detect_client_os
      client_collect_params
      # Phase 4 Plan 02 adds: client_download_chisel, client_check_socks_port, client_run
      log_info "Parameters collected. Binary download and connection not yet implemented."
  }
  ```

  NOTE: Do NOT call check_root() in client_main — client mode does not need root.
  </action>
  <verify>
  Run `bash -n proxyebator.sh` — no syntax errors.

  Test URL parsing:
  ```bash
  bash -c 'source proxyebator.sh; client_parse_url "wss://proxyebator:mytoken@example.com:2087/abcdef/" && echo "HOST=$CLIENT_HOST PORT=$CLIENT_PORT PATH=$CLIENT_PATH USER=$CLIENT_USER PASS=$CLIENT_PASS"'
  ```
  Expected: HOST=example.com PORT=2087 PATH=/abcdef/ USER=proxyebator PASS=mytoken

  Test URL without port:
  ```bash
  bash -c 'source proxyebator.sh; client_parse_url "wss://proxyebator:mytoken@example.com/secret/" && echo "PORT=$CLIENT_PORT"'
  ```
  Expected: PORT=443

  Note: Sourcing proxyebator.sh will trigger the entry point. To test individual functions, temporarily comment out the entry point OR run the full script in client mode with URL arg:
  ```bash
  bash proxyebator.sh client "wss://proxyebator:mytoken@example.com:2087/abcdef/" 2>&1 | grep "URL parsed"
  ```
  Expected output contains: URL parsed: host=example.com port=2087 path=/abcdef/ user=proxyebator
  </verify>
  <done>detect_client_os() detects Linux/Darwin. client_parse_url() handles wss:// URLs with and without port. client_collect_interactive() prompts in Russian for missing params. client_collect_params() orchestrates three input modes. client_main() calls detect_arch + detect_client_os + client_collect_params.</done>
</task>

</tasks>

<verification>
1. `bash -n proxyebator.sh` passes (no syntax errors)
2. `bash proxyebator.sh --help` shows CLIENT OPTIONS section
3. `bash proxyebator.sh client "wss://proxyebator:token@host.com:443/path/"` outputs "URL parsed" with correct components
4. `bash proxyebator.sh client --host test.com --path /abc/ --pass tok` does not crash on unknown flags
5. client_main does NOT call check_root
</verification>

<success_criteria>
- Three input modes (URL, flags, interactive) are implemented and wired
- URL parsing correctly extracts all 5 components from wss://user:pass@host:port/path/
- detect_client_os() returns "linux" or "darwin" per uname -s
- CLI parser accepts --host, --port, --path, --pass, --socks-port for client mode
- --port is mode-aware (LISTEN_PORT for server, CLIENT_PORT for client)
- Non-interactive stdin detection prevents hanging on missing params
- No root check in client_main
</success_criteria>

<output>
After completion, create `.planning/phases/04-client-mode/04-01-SUMMARY.md`
</output>
