---
phase: 02-server-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - SCRIPT-06
  - TUNNEL-01
  - TUNNEL-05
  - TUNNEL-06
  - MASK-01

must_haves:
  truths:
    - "Running server mode prompts for domain, validates DNS A-record, detects Cloudflare orange cloud"
    - "Running server mode prompts for masquerade mode (stub/proxy/static) with clear descriptions"
    - "Port 443 conflict is auto-detected and alternative ports are offered"
    - "Pre-install summary shows all collected parameters and asks for [y/N] confirmation"
    - "Non-interactive mode via CLI flags skips all prompts and summary"
    - "Dependencies (curl, openssl, nginx, certbot) are auto-installed if missing"
  artifacts:
    - path: "proxyebator.sh"
      provides: "server_collect_params, server_show_summary, server_install_deps functions"
      contains: "prompt_domain"
  key_links:
    - from: "server_main()"
      to: "server_collect_params()"
      via: "function call in sequence"
      pattern: "server_collect_params"
    - from: "server_collect_params()"
      to: "validate_domain()"
      via: "function call after domain prompt"
      pattern: "validate_domain"
    - from: "server_main()"
      to: "server_install_deps()"
      via: "function call after summary confirmation"
      pattern: "server_install_deps"
---

<objective>
Implement the interactive parameter collection flow, pre-install summary, and dependency auto-installation for server mode.

Purpose: Users running `./proxyebator.sh server` must be able to interactively provide domain, masquerade mode, and listen port --- or supply all values via CLI flags for non-interactive (AI-agent-friendly) execution. Dependencies must be installed before any binary download or service configuration.

Output: server_collect_params(), server_show_summary(), server_install_deps() functions wired into server_main(), replacing the Phase 1 stub.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-core/02-RESEARCH.md
@.planning/phases/02-server-core/02-CONTEXT.md
@.planning/phases/01-script-foundation/01-02-SUMMARY.md
@proxyebator.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement interactive parameter collection with domain validation</name>
  <files>proxyebator.sh</files>
  <action>
Add the following functions to proxyebator.sh, inserting them BETWEEN the secret generation functions (gen_auth_token) and the mode stubs section (server_main). Preserve the entry-point-at-bottom pattern established in Phase 1.

**server_collect_params():**
Orchestrates the parameter collection. Calls sub-functions in order:
1. prompt_domain() + validate_domain()
2. prompt_masquerade_mode()
3. detect_listen_port()
4. Set TUNNEL_TYPE to "chisel" (hardcoded for Phase 2; TUNNEL-01 satisfied by noting wstunnel is Phase 6)
5. Generate secrets: SECRET_PATH=$(gen_secret_path), AUTH_USER="proxyebator", AUTH_TOKEN=$(gen_auth_token)

**prompt_domain():**
- Check if $DOMAIN is already set (from CLI flag) --- if yes, log_info and return
- Otherwise: `printf "${CYAN}[?]${NC} Enter your domain name (e.g. example.com): "` then `read -r DOMAIN`
- Die if empty: `[[ -n "$DOMAIN" ]] || die "Domain is required"`

**validate_domain():**
- Format check: `printf '%s' "$DOMAIN" | grep -qE '^[a-zA-Z0-9][a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'` --- die if fails
- Get server public IP: try `curl -sf --max-time 5 https://api.ipify.org` then fallback to `curl -sf --max-time 5 https://ifconfig.me` then die
- Resolve domain A-record via DNS-over-HTTPS (no dig needed): `curl -sf --max-time 10 "https://dns.google/resolve?name=${DOMAIN}&type=A"` then extract IP with grep
- Die if domain_ip is empty: "Could not resolve domain --- check DNS A-record"
- Cloudflare detection: check first octet against known CF ranges (103|104|108|141|162|172|173|188|190|197|198). If match, log_warn about orange cloud + WebSocket timeout + suggest grey cloud. Do NOT abort.
- Compare domain_ip to server_ip --- die if mismatch: "Domain resolves to X but server IP is Y"
- log_info on success: "Domain resolves to server IP --- OK"

**prompt_masquerade_mode():**
- Check if $MASQUERADE_MODE is already set from CLI --- if yes, validate it is one of stub|proxy|static, log_info, return
- Show three options with descriptions:
  ```
  [?] Choose masquerade mode for the cover site:
    1) stub   — Minimal HTML page ("Under construction")
    2) proxy  — Reverse-proxy an external website (e.g. a blog)
    3) static — Serve your own static files from a local folder
  Choice [1]:
  ```
- Map 1/2/3/empty to stub/proxy/static (default=stub)
- If proxy: prompt for PROXY_URL (`Enter URL to proxy (e.g. https://example.blog): `) and validate non-empty
- If static: prompt for STATIC_PATH (`Enter path to static files directory: `) and validate directory exists with `[[ -d "$STATIC_PATH" ]]`

**detect_listen_port():**
- Check if $LISTEN_PORT is set from CLI --- if yes, log_info, return
- Check if port 443 is occupied: `ss -tlnp 2>/dev/null | grep -q ':443 '`
- If occupied: show the occupant process, warn about alternative ports (2087, 8443), prompt with default 2087
- If available: set LISTEN_PORT=443, log_info

All functions use the non-interactive bypass pattern: check CLI variable first, prompt only if empty. This satisfies non-interactive mode automatically.
  </action>
  <verify>
Run `bash -n proxyebator.sh` --- must exit 0 (no syntax errors).
Run `grep -c 'prompt_domain\|validate_domain\|prompt_masquerade_mode\|detect_listen_port\|server_collect_params' proxyebator.sh` --- must show all 5 function definitions plus calls.
  </verify>
  <done>
proxyebator.sh contains prompt_domain, validate_domain, prompt_masquerade_mode, detect_listen_port, and server_collect_params functions. Each prompt function checks CLI variable first and skips if set. validate_domain checks format, DNS A-record via dns.google, Cloudflare IP heuristic, and IP match.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement pre-install summary and dependency auto-installation</name>
  <files>proxyebator.sh</files>
  <action>
Add two more functions and rewire server_main().

**server_show_summary():**
- Print a bordered summary box:
  ```
  === Installation Summary ===
    Domain:       $DOMAIN
    Listen port:  $LISTEN_PORT
    Tunnel:       Chisel (port 7777, bound to 127.0.0.1)
    Secret path:  /$SECRET_PATH/
    Masquerade:   $MASQUERADE_MODE
  ```
- If MASQUERADE_MODE is "proxy", also print `  Proxy URL:    $PROXY_URL`
- If MASQUERADE_MODE is "static", also print `  Static path:  $STATIC_PATH`
- Ask `Continue with installation? [y/N]: ` --- abort on anything except y/yes (case-insensitive)
- **Non-interactive skip logic:** If CLI flags were provided for ALL required params (DOMAIN is set AND it was set BEFORE prompt_domain ran, meaning it came from CLI), skip the summary entirely. Use a flag variable `$CLI_MODE` --- set to "true" at the top of server_collect_params if `[[ -n "${DOMAIN:-}" ]]` before the first prompt. If CLI_MODE=true, log_info "Non-interactive mode: skipping confirmation" and return from server_show_summary.

**server_install_deps():**
- Run `$PKG_UPDATE` (already set by detect_os in Phase 1)
- Define list of required packages: `curl openssl nginx`
- For each package: check if installed via `command -v $pkg &>/dev/null`, install only if missing using `$PKG_INSTALL $pkg`
- For certbot: check if `command -v certbot` exists. If not:
  - Try snap first: `snap install --classic certbot 2>/dev/null && ln -sf /snap/bin/certbot /usr/bin/certbot 2>/dev/null`
  - If snap fails or not available: `$PKG_INSTALL certbot python3-certbot-nginx`
- Final check: `command -v certbot || die "certbot installation failed"`
- Also install jq if not present: `command -v jq &>/dev/null || $PKG_INSTALL jq`
- Log each installed package: `log_info "Installed: $pkg"` or `log_info "$pkg: already installed"`

**Rewire server_main():**
Replace the entire Phase 1 server_main stub with the real sequence:
```bash
server_main() {
    check_root
    detect_os
    detect_arch
    server_collect_params
    server_show_summary
    server_install_deps
    # Phase 2 Plan 02+ will add: server_download_chisel, server_setup_auth,
    # server_configure_nginx, server_obtain_tls, server_create_systemd,
    # server_configure_firewall, server_save_config, server_verify
    log_warn "Phase 2 Plan 01 complete: params collected, deps installed. Remaining steps in Plan 02+."
}
```

Remove the old server_main stub that just prints secrets.
  </action>
  <verify>
Run `bash -n proxyebator.sh` --- must exit 0.
Run `grep -c 'server_show_summary\|server_install_deps\|CLI_MODE' proxyebator.sh` --- must find all definitions.
Verify server_main calls: `grep -A 20 'server_main()' proxyebator.sh` --- must show check_root, detect_os, detect_arch, server_collect_params, server_show_summary, server_install_deps in order.
  </verify>
  <done>
server_show_summary displays all collected params and asks [y/N], with non-interactive bypass via CLI_MODE flag. server_install_deps installs curl, openssl, nginx, certbot (snap preferred), jq using OS-specific package manager from Phase 1. server_main is rewired to call the full param-collection-to-deps-install pipeline.
  </done>
</task>

</tasks>

<verification>
1. `bash -n proxyebator.sh` exits 0 (no syntax errors)
2. All 7 new functions exist: prompt_domain, validate_domain, prompt_masquerade_mode, detect_listen_port, server_collect_params, server_show_summary, server_install_deps
3. server_main calls: check_root -> detect_os -> detect_arch -> server_collect_params -> server_show_summary -> server_install_deps
4. Non-interactive mode: grep confirms CLI variable checks (`[[ -n "${DOMAIN:-}" ]]`) before each prompt
5. DNS validation uses dns.google (no dig/host dependency): grep confirms `dns.google/resolve`
6. Cloudflare detection: grep confirms first-octet heuristic with known CF ranges
</verification>

<success_criteria>
- Running `bash -n proxyebator.sh` succeeds
- All interactive prompts check CLI flag before prompting (non-interactive bypass)
- validate_domain checks format, DNS A-record, CF detection, IP match
- server_install_deps installs missing packages idempotently
- server_main is fully rewired from stub to real sequence
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-core/02-01-SUMMARY.md`
</output>
