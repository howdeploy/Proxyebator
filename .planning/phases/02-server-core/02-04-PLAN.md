---
phase: 02-server-core
plan: 04
type: execute
wave: 4
depends_on:
  - 02-03
files_modified:
  - proxyebator.sh
autonomous: true
requirements:
  - SRV-02
  - SRV-03
  - SRV-04

must_haves:
  truths:
    - "Firewall opens 80 and the listen port (443 or alternate), blocks tunnel port 7777 from external access"
    - "ufw is used when active, iptables is the fallback --- ufw is NEVER enabled by the script (SSH lockout risk)"
    - "Configuration file at /etc/proxyebator/server.conf stores domain, port, path, tunnel type, masquerade mode, auth credentials, nginx and cert paths"
    - "Post-install verification checks: systemd active, port bound to 127.0.0.1, decoy site HTTP 200, WebSocket path reachable"
    - "Connection info is printed: client command, SOCKS5 address, config file path"
  artifacts:
    - path: "proxyebator.sh"
      provides: "server_configure_firewall, server_save_config, server_verify, server_print_connection_info functions"
      contains: "server_configure_firewall"
    - path: "/etc/proxyebator/server.conf"
      provides: "Server configuration for uninstall and status"
      contains: "DOMAIN="
  key_links:
    - from: "server_main()"
      to: "server_verify()"
      via: "last function call in sequence"
      pattern: "server_verify"
    - from: "server_verify()"
      to: "server_print_connection_info()"
      via: "called after all checks pass"
      pattern: "server_print_connection_info"
    - from: "server_configure_firewall()"
      to: "ufw or iptables"
      via: "command -v ufw detection"
      pattern: "command -v ufw"
---

<objective>
Configure the firewall, save installation config, verify everything works, and print connection information.

Purpose: The firewall ensures the tunnel port is not exposed externally. The config file enables clean uninstall in Phase 5. The verification catches silent failures before telling the user "it works." The connection info gives the user everything they need to connect.

Output: server_configure_firewall(), server_save_config(), server_verify(), server_print_connection_info() functions completing the full server_main() pipeline.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-core/02-RESEARCH.md
@.planning/phases/02-server-core/02-CONTEXT.md
@.planning/phases/02-server-core/02-03-SUMMARY.md
@proxyebator.sh
@tunnel-reference.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement firewall configuration and config file save</name>
  <files>proxyebator.sh</files>
  <action>
Add two functions after server_obtain_tls() / write_nginx_ssl_config() and before server_main().

**server_configure_firewall():**
Three-tier firewall logic:

1. If `command -v ufw &>/dev/null && ufw status 2>/dev/null | grep -q "Status: active"`:
   - ufw is installed AND active --- use ufw
   ```bash
   ufw allow 80/tcp comment "proxyebator HTTP" 2>/dev/null || true
   ufw allow "${LISTEN_PORT}/tcp" comment "proxyebator HTTPS" 2>/dev/null || true
   ufw deny 7777/tcp comment "proxyebator tunnel internal" 2>/dev/null || true
   log_info "Firewall configured via ufw: 80/tcp ALLOW, ${LISTEN_PORT}/tcp ALLOW, 7777/tcp DENY"
   ```

2. Elif `command -v ufw &>/dev/null`:
   - ufw installed but NOT active --- log_warn "ufw installed but not active --- using iptables instead"
   - CRITICAL: Do NOT run `ufw enable` --- this can lock out SSH
   - Fall through to iptables

3. Else:
   - log_info "ufw not found --- configuring via iptables"
   - Use iptables with idempotent check-before-add:
   ```bash
   iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null \
       || iptables -A INPUT -p tcp --dport 80 -j ACCEPT
   iptables -C INPUT -p tcp --dport "${LISTEN_PORT}" -j ACCEPT 2>/dev/null \
       || iptables -A INPUT -p tcp --dport "${LISTEN_PORT}" -j ACCEPT
   iptables -C INPUT -p tcp --dport 7777 ! -i lo -j DROP 2>/dev/null \
       || iptables -A INPUT -p tcp --dport 7777 ! -i lo -j DROP
   log_info "Firewall configured via iptables: 80 ALLOW, ${LISTEN_PORT} ALLOW, 7777 DROP (non-lo)"
   ```

The `! -i lo` on the deny rule is important: localhost connections to 7777 (from nginx) must still work; only external access is blocked.

**server_save_config():**
- Ensure directory: `mkdir -p /etc/proxyebator`
- Write config:
  ```bash
  cat > /etc/proxyebator/server.conf << EOF
  # proxyebator server configuration
  # Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
  DOMAIN=${DOMAIN}
  LISTEN_PORT=${LISTEN_PORT}
  SECRET_PATH=${SECRET_PATH}
  TUNNEL_TYPE=chisel
  TUNNEL_PORT=7777
  MASQUERADE_MODE=${MASQUERADE_MODE}
  AUTH_USER=${AUTH_USER}
  AUTH_TOKEN=${AUTH_TOKEN}
  NGINX_CONF=${NGINX_CONF_PATH}
  CERT_PATH=${CERT_PATH:-/etc/letsencrypt/live/${DOMAIN}/fullchain.pem}
  CERT_KEY_PATH=${CERT_KEY_PATH:-/etc/letsencrypt/live/${DOMAIN}/privkey.pem}
  EOF
  ```
- Set permissions: `chmod 600 /etc/proxyebator/server.conf`
- Log: `log_info "Config saved: /etc/proxyebator/server.conf"`
  </action>
  <verify>
Run `bash -n proxyebator.sh` --- must exit 0.
Verify firewall function: `grep 'server_configure_firewall' proxyebator.sh` --- must exist.
Verify ufw is NEVER enabled: `grep -c 'ufw enable' proxyebator.sh` --- must be 0.
Verify iptables uses check-before-add: `grep 'iptables -C' proxyebator.sh` --- must be present.
Verify config save: `grep 'server_save_config' proxyebator.sh` --- must exist.
Verify config file has chmod 600: `grep 'chmod 600.*server.conf' proxyebator.sh` --- must be present.
  </verify>
  <done>
server_configure_firewall uses ufw when active, iptables as fallback, never enables ufw. Opens 80 and LISTEN_PORT, blocks 7777 from external (allows localhost via ! -i lo). server_save_config writes all params to /etc/proxyebator/server.conf with chmod 600.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement post-install verification, connection info, and finalize server_main</name>
  <files>proxyebator.sh</files>
  <action>
Add two functions and finalize server_main().

**server_verify():**
Run four verification checks with PASS/FAIL output:

1. **Service active (SRV-01 check):**
   ```bash
   if systemctl is-active --quiet chisel 2>/dev/null; then
       log_info "[PASS] chisel.service is active"
   else
       log_warn "[FAIL] chisel.service is NOT active"
       systemctl status chisel --no-pager >&2 2>/dev/null || true
       all_ok=false
   fi
   ```

2. **Port bound to 127.0.0.1 (SRV-04):**
   ```bash
   if ss -tlnp 2>/dev/null | grep ':7777 ' | grep -q '127.0.0.1'; then
       log_info "[PASS] Tunnel port 7777 bound to 127.0.0.1"
   else
       log_warn "[FAIL] Tunnel port 7777 NOT bound to 127.0.0.1 --- SECURITY RISK"
       ss -tlnp 2>/dev/null | grep ':7777 ' >&2 || true
       all_ok=false
   fi
   ```

3. **Decoy site returns 200:**
   ```bash
   local http_code
   http_code=$(curl -sk --max-time 10 -o /dev/null -w "%{http_code}" "https://${DOMAIN}/" 2>/dev/null || echo "000")
   if [[ "$http_code" == "200" ]]; then
       log_info "[PASS] Cover site https://${DOMAIN}/ returns HTTP 200"
   else
       log_warn "[FAIL] Cover site returned HTTP $http_code (expected 200)"
       all_ok=false
   fi
   ```

4. **WebSocket path reachable:**
   ```bash
   local ws_code
   ws_code=$(curl -sk --max-time 10 -o /dev/null -w "%{http_code}" \
       "https://${DOMAIN}:${LISTEN_PORT}/${SECRET_PATH}/" 2>/dev/null || echo "000")
   if [[ "$ws_code" == "404" || "$ws_code" == "200" || "$ws_code" == "101" ]]; then
       log_info "[PASS] WebSocket path /${SECRET_PATH}/ is reachable (HTTP $ws_code)"
   else
       log_warn "[FAIL] WebSocket path returned HTTP $ws_code"
       all_ok=false
   fi
   ```
   Note: 404 is normal without WebSocket upgrade headers. 101 means upgrade succeeded. Both are acceptable.

After all checks: if all_ok=true, print a success banner. If any failed, print a warning but STILL print connection info (partial success is still useful).

**server_print_connection_info():**
Print a clear, copy-paste-friendly connection block:
```
=== Connection Information ===
Server setup complete!

  Client command:
  chisel client \
    --auth "AUTH_USER:AUTH_TOKEN" \
    --keepalive 25s \
    https://DOMAIN:LISTEN_PORT/SECRET_PATH/ \
    socks

  SOCKS5 proxy will be available at: 127.0.0.1:1080

  Server config file: /etc/proxyebator/server.conf

Note: Use 'socks' (not 'R:socks') --- 'socks' means traffic exits via server.
Note: The trailing slash in the URL is required.
```
Use printf with proper color codes for the connection command (CYAN for the command, GREEN for success, YELLOW for notes).

**Finalize server_main():**
Replace the placeholder log_warn at the end with the complete sequence:
```bash
server_main() {
    check_root
    detect_os
    detect_arch
    server_collect_params
    server_show_summary
    server_install_deps
    server_download_chisel
    server_setup_auth
    server_create_systemd
    server_configure_nginx
    server_obtain_tls
    server_configure_firewall
    server_save_config
    server_verify
}
```
No trailing log_warn or placeholder --- server_verify handles the final output including server_print_connection_info.
  </action>
  <verify>
Run `bash -n proxyebator.sh` --- must exit 0.
Verify all four checks: `grep -c '\[PASS\]\|\[FAIL\]' proxyebator.sh` --- must have at least 8 occurrences (4 pass + 4 fail paths).
Verify SRV-04 check: `grep 'ss -tlnp.*7777.*127.0.0.1' proxyebator.sh` --- must be present.
Verify connection info: `grep 'socks' proxyebator.sh` --- must show the client command with 'socks' (not 'R:socks').
Verify server_main is complete: `grep -A 20 'server_main()' proxyebator.sh` --- must show ALL 13 function calls in order (check_root through server_verify), NO placeholder log_warn at end.
Verify the script line count: `wc -l proxyebator.sh` --- should be roughly 500-700 lines (significant growth from Phase 1's 209 lines).
  </verify>
  <done>
server_verify runs four PASS/FAIL checks (service active, port binding, decoy site 200, WebSocket path reachable). server_print_connection_info outputs copy-paste client command with auth, SOCKS5 address, and notes. server_main is finalized with the complete 13-function pipeline from check_root through server_verify. No more placeholders.
  </done>
</task>

</tasks>

<verification>
1. `bash -n proxyebator.sh` exits 0
2. Firewall: ufw used when active, iptables fallback, ufw NEVER enabled by script
3. Config file written to /etc/proxyebator/server.conf with chmod 600
4. Four verification checks with PASS/FAIL output
5. SRV-04: explicit ss -tlnp check for 127.0.0.1:7777
6. Connection info printed with copy-paste client command
7. server_main is complete: 13 function calls, no placeholders
8. Script is syntactically valid (bash -n passes)
</verification>

<success_criteria>
- Firewall properly configured with ufw or iptables
- /etc/proxyebator/server.conf contains all necessary parameters for uninstall
- All four verification checks produce clear PASS/FAIL output
- Connection info is copy-paste ready with correct socks (not R:socks) and trailing slash
- server_main represents the complete server installation pipeline
- Running `./proxyebator.sh server` on a VPS would execute the full install sequence
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-core/02-04-SUMMARY.md`
</output>
