---
phase: 03-verification-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [proxyebator.sh]
autonomous: true
requirements: [VER-01, VER-02]

must_haves:
  truths:
    - "verify_main() runs all 7 checks without stopping on first failure"
    - "Each check prints [PASS] or [FAIL] with descriptive text"
    - "Failed checks include diagnostic output and a Try: hint"
    - "Summary banner shows exact pass/fail count (X/7 format)"
    - "verify_main returns 0 on all pass, 1 on any fail"
    - "Port bound to 0.0.0.0 instead of 127.0.0.1 triggers [FAIL]"
    - "WebSocket check sends proper upgrade headers per VER-02"
  artifacts:
    - path: "proxyebator.sh"
      provides: "verify_main function with 7 checks"
      contains: "verify_main()"
  key_links:
    - from: "verify_main()"
      to: "/etc/proxyebator/server.conf"
      via: "source command"
      pattern: "source /etc/proxyebator/server.conf"
    - from: "verify_main()"
      to: "check_pass / check_fail helpers"
      via: "function calls incrementing fail_count"
      pattern: "fail_count="
---

<objective>
Build the complete verify_main() function with all 7 verification checks, helper functions (check_pass, check_fail), and the summary banner with pass/fail counting.

Purpose: This is the core verification engine that catches every silent failure mode (dead service, exposed port, broken TLS, DNS drift, missing firewall rules) before telling the user installation succeeded.
Output: verify_main() function added to proxyebator.sh, ready for wiring into CLI and server_main (Plan 02).
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-verification-suite/03-CONTEXT.md
@.planning/phases/03-verification-suite/03-RESEARCH.md
@proxyebator.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check_pass/check_fail helpers and verify_main scaffold</name>
  <files>proxyebator.sh</files>
  <action>
Add two helper functions and the verify_main() scaffold ABOVE server_main() (between server_print_connection_info and server_verify). These are module-level functions, not nested inside verify_main — this avoids bash scoping issues with fail_count.

**check_pass():**
- Takes one argument: description string
- Prints: `${GREEN}[PASS]${NC} %s\n` using printf with %s

**check_fail():**
- Takes one argument: description string
- Prints to stderr: `${RED}[FAIL]${NC} %s\n` using printf with %s to stderr (>&2)
- NOTE: Does NOT increment fail_count — callers do that inline because fail_count is local to verify_main
- OVERRIDE NOTE: Do NOT follow the RESEARCH.md pattern (lines 147-163) where check_fail increments fail_count internally. check_fail here ONLY prints. Callers increment fail_count inline with `fail_count=$(( fail_count + 1 ))`. This is required for TLS check 6's tls_ok sub-condition logic — TLS has multiple sub-failures but must only increment fail_count ONCE at the end via the tls_ok flag.

**verify_main() scaffold:**
1. Source /etc/proxyebator/server.conf — die if file not found with message "server.conf not found --- run: sudo ./proxyebator.sh server"
2. Use `# shellcheck disable=SC1091` before source
3. Declare `local fail_count=0` and `local total_checks=7`
4. Print header: `${BOLD}=== Verification Suite ===${NC}`
5. (Space for 7 checks — implemented in Task 2)
6. Summary banner at end:
   - `local pass_count=$(( total_checks - fail_count ))`
   - If fail_count == 0: green `=== ALL CHECKS PASSED (X/7) ===` then call server_print_connection_info, return 0
   - If fail_count > 0: red `=== X CHECK(S) FAILED (Y/7 passed) ===` to stderr, return 1
   - Connection block ONLY on ALL PASS (per locked decision)

IMPORTANT bash safety:
- Separate `local` declaration from assignment for any command substitution
- All diagnostic commands in else/fail branches MUST have `|| true` appended
- Never call `die` inside verify_main — use check_fail + continue pattern
  </action>
  <verify>
Search proxyebator.sh for "verify_main()" — function exists. Search for "check_pass()" and "check_fail()" — both exist. Search for "ALL CHECKS PASSED" — banner exists. Search for "server_print_connection_info" inside verify_main — only called in the all-pass branch.
  </verify>
  <done>
verify_main() function exists in proxyebator.sh with scaffold: sources server.conf, declares fail_count=0, has summary banner with pass/fail counting, calls server_print_connection_info only when fail_count==0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement all 7 verification checks inside verify_main</name>
  <files>proxyebator.sh</files>
  <action>
Add all 7 checks inside verify_main() between the header printf and the summary banner. Follow the exact order from research (optimal for diagnostics — infrastructure first, network last).

Use the code examples from 03-RESEARCH.md as the primary reference. Key adaptations:

**Check 1: systemd service active**
- `systemctl is-active --quiet proxyebator` in if-condition
- PASS: "proxyebator.service is active"
- FAIL: diagnostic via `systemctl status proxyebator --no-pager --lines=5 >&2 2>/dev/null || true`
- Try hint: `systemctl restart proxyebator`
- `fail_count=$(( fail_count + 1 ))` on fail

**Check 2: Tunnel port bound to 127.0.0.1**
- Use `TUNNEL_PORT` from server.conf (NOT hardcoded 7777)
- `ss -tlnp | grep ":${TUNNEL_PORT} " | grep -q '127\.0\.0\.1'`
- FAIL message: "SECURITY RISK" emphasis
- Diagnostic: show ss output for that port
- `fail_count=$(( fail_count + 1 ))` on fail

**Check 3: Firewall blocks tunnel port**
- Mirror Phase 2 decision tree exactly: `if command -v ufw && ufw status | grep "Status: active"` then check ufw, else check iptables
- ufw: grep for TUNNEL_PORT + DENY
- iptables: `iptables -L INPUT -n | grep "dpt:${TUNNEL_PORT}"`
- `fail_count=$(( fail_count + 1 ))` on fail

**Check 4: Cover site returns HTTP 200**
- `local http_code; http_code=$(curl ...) || http_code="000"` — SEPARATE local declaration from assignment
- curl with -sk --max-time 10 to `https://${DOMAIN}/`
- FAIL: show verbose curl output
- `fail_count=$(( fail_count + 1 ))` on fail

**Check 5: WebSocket path reachable (VER-02 specific)**
- `local ws_code; ws_code=$(curl ...) || ws_code="000"` — SEPARATE local from assignment
- MUST include WebSocket upgrade headers per VER-02: Connection: Upgrade, Upgrade: websocket, Sec-WebSocket-Key, Sec-WebSocket-Version: 13
- Use `https://${DOMAIN}:${LISTEN_PORT}/${SECRET_PATH}/` — note trailing slash
- Accept 101, 200, 400 as PASS (not 404, not 000)
- `fail_count=$(( fail_count + 1 ))` on fail

**Check 6: TLS certificate validity + chain + renewal timer**
- This is ONE check (one fail_count increment max) with multiple sub-conditions
- Use `local tls_ok=true` internal flag
- CERT_PATH from server.conf — check file exists first
- `openssl x509 -noout -checkend 2592000` — exit 0 means cert valid for 30+ days (checkend semantics: 0=safe)
- Chain of trust: try /etc/ssl/certs/ca-certificates.crt then /etc/pki/tls/certs/ca-bundle.crt
- Renewal timer: `systemctl list-units --type=timer | grep -qE "certbot\.timer|snap\.certbot\.renew"` (handle both names per research pitfall 5)
- Only increment fail_count once at end if tls_ok==false

**Check 7: DNS resolves to server IP**
- Get server_ip via api.ipify.org fallback ifconfig.me (same pattern as validate_domain)
- Get domain_ip via dns.google/resolve DoH (same pattern as validate_domain)
- Cloudflare orange cloud detection by first octet (103|104|108|141|162|172|173|188|190|197|198)
- Separate local declarations from assignments throughout
- `fail_count=$(( fail_count + 1 ))` on fail

CRITICAL SAFETY RULES (from research pitfalls):
1. Every diagnostic command in FAIL branches: append `|| true` (set -e protection)
2. Every `local var; var=$(cmd)` must be TWO statements, never `local var=$(cmd)`
3. Never use `die` — only check_fail + continue
4. TLS check: `if openssl x509 -checkend ...; then PASS` — the if-branch is PASS (checkend 0 = safe)
  </action>
  <verify>
Count occurrences of "check_pass" in verify_main — should be 7 (one per check on success path). Count occurrences of "check_fail" — will be MORE than 7 because TLS and DNS checks have multiple sub-condition fail paths, but that's expected. The key invariant: search for "fail_count=$(( fail_count + 1 ))" — should appear exactly 7 times (one per check, TLS uses tls_ok flag for single increment). Search for `local.*=.*$(` — should return 0 results inside verify_main (all local declarations separated from assignments). Grep for "|| true" in verify_main fail branches — every diagnostic command guarded.
  </verify>
  <done>
All 7 checks implemented inside verify_main: (1) systemd active, (2) port 127.0.0.1, (3) firewall rules, (4) cover site HTTP 200, (5) WebSocket upgrade with proper headers, (6) TLS cert+chain+timer, (7) DNS resolution. Each check prints [PASS] or [FAIL], shows diagnostics on failure, and increments fail_count. The function runs all checks regardless of individual failures.
  </done>
</task>

</tasks>

<verification>
1. `grep -c "check_pass" proxyebator.sh` returns at least 7 (one per check success path)
2. `grep -c "check_fail" proxyebator.sh` returns at least 7
3. `grep -c "fail_count=\$(( fail_count + 1 ))" proxyebator.sh` returns exactly 7
4. `grep "verify_main()" proxyebator.sh` shows function definition
5. `grep "ALL CHECKS PASSED" proxyebator.sh` shows summary banner
6. `grep "Upgrade: websocket" proxyebator.sh` confirms VER-02 WebSocket headers
7. `grep "Sec-WebSocket-Key" proxyebator.sh` confirms VER-02 WebSocket headers
8. `grep "server_print_connection_info" proxyebator.sh` inside verify_main appears only in fail_count==0 branch
9. No `local.*=.*$(` pattern inside verify_main (separated declarations)
10. `bash -n proxyebator.sh` returns 0 (syntax valid)
</verification>

<success_criteria>
- verify_main() contains 7 checks that each print [PASS] or [FAIL]
- Port binding check (check 2) flags 0.0.0.0 as FAIL with "SECURITY RISK"
- WebSocket check (check 5) sends proper upgrade headers (VER-02)
- TLS check is one counter increment with internal sub-conditions
- Summary banner shows exact X/7 count
- Connection info printed ONLY on ALL PASS
- Function returns 0 on all pass, 1 on any fail
- Script passes bash -n syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification-suite/03-01-SUMMARY.md`
</output>
